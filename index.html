<html>

<head>
<title>Learning WebGL &mdash; lesson 1</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

  <link rel="stylesheet" href="css/app.css"/>

<script type="text/javascript" src="utils/jquery-1.11.2.min.js"></script>
<script type="text/javascript" src="utils/gl-matrix.js"></script>
<script type="text/javascript" src="utils/loadShaderUtil.js"></script>
<script type="text/javascript" src="utils/webgl-obj-loader.js"></script>
<script type="text/javascript" src="utils/webgl-utils.js"></script>
<script type="text/javascript" src="utils/terrain.js"></script>
<script type="text/javascript" src="utils/keyboardControls.js"></script>

<script type="text/javascript">

    var gl;
    var keyboardControls;
    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.getExtension('OES_standard_derivatives');
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    function handleKeyDown(event) {
        keyboardControls.handleKeyDown(event);
    }

    function handleKeyUp(event) {
        keyboardControls.handleKeyUp(event);
    }
	
    var teapotShader;
	var skyBoxShaders;
    var terrainShader;

    function setTeapotShaderProgramVars() {
        gl.useProgram(teapotShader);

        teapotShader.vertexPositionAttribute = gl.getAttribLocation(teapotShader, "aVertexPosition");
        gl.enableVertexAttribArray(teapotShader.vertexPositionAttribute);

        teapotShader.vertexNormalAttribute = gl.getAttribLocation(teapotShader, "aVertexNormal");
        gl.enableVertexAttribArray(teapotShader.vertexNormalAttribute);

        teapotShader.textureCoordAttribute = gl.getAttribLocation(teapotShader, "aTextureCoord");
        gl.enableVertexAttribArray(teapotShader.textureCoordAttribute);

        teapotShader.frustum = gl.getUniformLocation(teapotShader, "frustum");
        teapotShader.camMatrix = gl.getUniformLocation(teapotShader, "camMatrix");
        teapotShader.mvMatrixUniform = gl.getUniformLocation(teapotShader, "uMVMatrix");
        teapotShader.nMatrixUniform = gl.getUniformLocation(teapotShader, "uNMatrix");
        teapotShader.samplerUniform = gl.getUniformLocation(teapotShader, "uSampler");
        teapotShader.materialShininessUniform = gl.getUniformLocation(teapotShader, "uMaterialShininess");
        teapotShader.showSpecularHighlightsUniform = gl.getUniformLocation(teapotShader, "uShowSpecularHighlights");
        teapotShader.useTexturesUniform = gl.getUniformLocation(teapotShader, "uUseTextures");
        teapotShader.useLightingUniform = gl.getUniformLocation(teapotShader, "uUseLighting");
        teapotShader.ambientColorUniform = gl.getUniformLocation(teapotShader, "uAmbientColor");
        teapotShader.pointLightingLocationUniform = gl.getUniformLocation(teapotShader, "uPointLightingLocation");
        teapotShader.pointLightingSpecularColorUniform = gl.getUniformLocation(teapotShader, "uPointLightingSpecularColor");
        teapotShader.pointLightingDiffuseColorUniform = gl.getUniformLocation(teapotShader, "uPointLightingDiffuseColor");
    }

    function setskyBoxShaderProgramVars(){
        gl.useProgram(skyBoxShaders);

        skyBoxShaders.vertexPositionAttribute = gl.getAttribLocation(skyBoxShaders, "aVertexPosition");
        gl.enableVertexAttribArray(skyBoxShaders.vertexPositionAttribute);

        skyBoxShaders.textureCoordAttribute = gl.getAttribLocation(skyBoxShaders, "aTexCoord");
        gl.enableVertexAttribArray(skyBoxShaders.textureCoordAttribute);

        skyBoxShaders.camMatrix = gl.getUniformLocation(skyBoxShaders, "camMatrix");
        skyBoxShaders.frustum = gl.getUniformLocation(skyBoxShaders, "frustum");
        skyBoxShaders.samplerUniform = gl.getUniformLocation(skyBoxShaders, "uTexSky");
    }

    function setTerrainShaderProgramVars() {
        gl.useProgram(terrainShader);

        terrainShader.vertexPositionAttribute = gl.getAttribLocation(terrainShader, "aVertexPosition");
        gl.enableVertexAttribArray(terrainShader.vertexPositionAttribute);

        terrainShader.vertexNormalAttribute = gl.getAttribLocation(terrainShader, "aVertexNormal");
        gl.enableVertexAttribArray(terrainShader.vertexNormalAttribute);

        terrainShader.vertexColorAttribute = gl.getAttribLocation(terrainShader, "aColorAttrib");
        gl.enableVertexAttribArray(terrainShader.vertexColorAttribute);

        // terrainShader.textureCoordAttribute = gl.getAttribLocation(terrainShader, "aTextureCoord");
        // gl.enableVertexAttribArray(terrainShader.textureCoordAttribute);

        terrainShader.mvMatrixUniform = gl.getUniformLocation(terrainShader, "uMVMatrix");
        terrainShader.frustum = gl.getUniformLocation(terrainShader, "frustum");
        terrainShader.camMatrix = gl.getUniformLocation(terrainShader, "camMatrix");
        terrainShader.samplerUniform = gl.getUniformLocation(terrainShader, "uTexBump");
        terrainShader.nMatrixUniform = gl.getUniformLocation(terrainShader, "uNMatrix");
    }

    function initShaders() {

        teapotShader = utils.addShaderProg(gl, 'teapot.vertex', 'teapot.frag');
        terrainShader = utils.addShaderProg(gl, 'terrain.vertex', 'terrain.frag');
		skyBoxShaders = utils.addShaderProg(gl, 'skyBox.vertex', 'skyBox.frag');

        setTeapotShaderProgramVars();
        setTerrainShaderProgramVars();
        setskyBoxShaderProgramVars();

    }

    function handleLoadedTexture(texture) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.bindTexture(gl.TEXTURE_2D, null);
        texture.isFinished = true;
    }

    function handleLoadedHeightMap(texture) {
        gl.useProgram(terrainShader);
        terrain = new TerrainBlock(terrainHeightMap, 256, 256);
        terrain.isFinished = false;

        var pos = mat4.create();
        mat4.identity(pos);
        mat4.translate(pos, pos, [ -80, -15, -80]);

        terrain.positionMatrix = pos;
        terrain.buildVertices();
        terrain.buildIndices();
        terrain.buildBuffers(gl);
    }

    var galvanizedTexture;
    var earthTexture;
	var skyTexture;
	var terrainHeightMap;
    var oneByOneTexture;
    var noiseBumpMap;

    function initTextures() {

        oneByOneTexture = gl.createTexture();
        oneByOneTexture.isFinished = false;
        oneByOneTexture.image = new Image();
        oneByOneTexture.image.onload = function () {
            handleLoadedTexture(oneByOneTexture)
        }
        oneByOneTexture.image.src = "textures/1x1.jpg";

        galvanizedTexture = gl.createTexture();
        galvanizedTexture.isFinished = false;
        galvanizedTexture.image = new Image();
        galvanizedTexture.image.onload = function () {
            handleLoadedTexture(galvanizedTexture)
        }
        galvanizedTexture.image.src = "textures/arroway.de_metal+structure+06_d100_flat.jpg";

        noiseBumpMap = gl.createTexture();
        noiseBumpMap.isFinished = false;
        noiseBumpMap.image = new Image();
        noiseBumpMap.image.onload = function () {
            handleLoadedTexture(noiseBumpMap)
        }
        noiseBumpMap.image.src = "textures/noise.jpg";

        earthTexture = gl.createTexture();
        earthTexture.isFinished = false;
        earthTexture.image = new Image();
        earthTexture.image.onload = function () {
            handleLoadedTexture(earthTexture)
        }
        earthTexture.image.src = "textures/earth.jpg";
		
		skyTexture = gl.createTexture();
        skyTexture.isFinished = false;
        skyTexture.image = new Image();
        skyTexture.image.onload = function () {
            handleLoadedTexture(skyTexture)
        }
        skyTexture.image.src = "textures/SkyBox512.jpg";

        terrainHeightMap = new Image();
        terrainHeightMap.onload = function () {
            handleLoadedHeightMap(terrainHeightMap)
        }
        terrainHeightMap.src = "textures/fft-terrain.jpg";
        // terrainHeightMap.src = "textures/44-terrain.jpg";
    }

    var frustum = mat4.create();

    function setMatrixUniforms(shader, model) {
        gl.uniformMatrix4fv(shader.mvMatrixUniform, false, model.positionMatrix);

        var normalMatrix = mat3.create();
        mat3.fromMat4(normalMatrix, model.positionMatrix);
        mat3.invert(normalMatrix, normalMatrix);
        mat3.transpose(normalMatrix, normalMatrix);
        gl.uniformMatrix3fv(shader.nMatrixUniform, false, normalMatrix);
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    var ourMeshes = {};
    var ourObjects = [];
    var terrain = {};

    function webGLAddObj(meshes){
        ourMeshes = meshes;
        OBJ.initMeshBuffers(gl, ourMeshes.teapot);
		OBJ.initMeshBuffers(gl, ourMeshes.skyBox);
        OBJ.initMeshBuffers(gl, ourMeshes.eHouse);
        createObjects();
    }

	var skyBox;
    function createObjects(){
        var teapot1, teapot2, mesh, skyBoxMesh, eHouse;
        mesh = ourMeshes.teapot;
		
        teapot1 = {name:"teapot1"};
        teapot1.meshData = mesh;
		teapot1.radius = 1;

        teapot2 = {name:"teapot2"};
        teapot2.meshData = mesh;
		teapot2.radius = 1;

		skyBoxMesh = ourMeshes.skyBox;
		
		skyBox = {name:"skyBox"};
		skyBox.meshData = skyBoxMesh;
		skyBox.radius = 5;
		
		teapot2.radius = 5;
        eHouse = {name: "eHouse"};
        eHouse.meshData = ourMeshes.eHouse;
        eHouse.radius = 1;

        var skyMat = mat4.create(), teapot1Mat = mat4.create(), teapot2Mat = mat4.create(), eHouseMat = mat4.create();

        mat4.identity(skyMat);
        mat4.translate(skyMat, skyMat, [ 0, -4, 0]);
        skyBox.positionMatrix = skyMat;

        mat4.identity(teapot1Mat);
        mat4.translate(teapot1Mat, teapot1Mat, [-10, 0, -40]);
        mat4.rotate(teapot1Mat, teapot1Mat, degToRad(23.4), [1, 0, -1]);
        mat4.rotate(teapot1Mat, teapot1Mat, degToRad(teapotAngle), [0, 1, 0]);
        teapot1.positionMatrix = teapot1Mat;
        ourObjects.push(teapot1);

        mat4.identity(teapot2Mat);
        mat4.translate(teapot2Mat, teapot2Mat, [10, 0, -40]);
        mat4.rotate(teapot2Mat, teapot2Mat, degToRad(-23.4), [1, 0, -1]);
        mat4.rotate(teapot2Mat, teapot2Mat, degToRad(-teapotAngle), [0, 1, 0]);
        teapot2.positionMatrix = teapot2Mat;
        ourObjects.push(teapot2);
		
        mat4.identity(eHouseMat);
        mat4.translate(eHouseMat, eHouseMat, [-10, 10, -40]);
        // mat4.rotate(eHouseMat, eHouseMat, degToRad(23.4), [1, 0, -1]);
        // mat4.rotate(eHouseMat, eHouseMat, degToRad(teapotAngle), [0, 1, 0]);
        eHouse.positionMatrix = eHouseMat;
        //ourObjects.push(eHouse);
    }

    var teapotAngle = 180;

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		if(skyBox != null){
		      drawSkyBox();
		}
		gl.useProgram(teapotShader);
        
        var specularHighlights = document.getElementById("specular").checked;
        gl.uniform1i(teapotShader.showSpecularHighlightsUniform, specularHighlights);

        var lighting = document.getElementById("lighting").checked;
        gl.uniform1i(teapotShader.useLightingUniform, lighting);
        if (lighting) {
           gl.uniform3f(
               teapotShader.ambientColorUniform,
               parseFloat(document.getElementById("ambientR").value),
               parseFloat(document.getElementById("ambientG").value),
               parseFloat(document.getElementById("ambientB").value)
           );

           gl.uniform3f(
               teapotShader.pointLightingLocationUniform,
               parseFloat(document.getElementById("lightPositionX").value),
               parseFloat(document.getElementById("lightPositionY").value),
               parseFloat(document.getElementById("lightPositionZ").value)
           );

           gl.uniform3f(
               teapotShader.pointLightingSpecularColorUniform,
               parseFloat(document.getElementById("specularR").value),
               parseFloat(document.getElementById("specularG").value),
               parseFloat(document.getElementById("specularB").value)
           );

           gl.uniform3f(
               teapotShader.pointLightingDiffuseColorUniform,
               parseFloat(document.getElementById("diffuseR").value),
               parseFloat(document.getElementById("diffuseG").value),
               parseFloat(document.getElementById("diffuseB").value)
           );
        }

        var texture = document.getElementById("texture").value;
        gl.uniform1i(teapotShader.useTexturesUniform, texture != "none");

        gl.activeTexture(gl.TEXTURE0);
        if (texture == "earth") {
            if (earthTexture.isFinished) {
                gl.bindTexture(gl.TEXTURE_2D, earthTexture);
            } else{
                gl.bindTexture(gl.TEXTURE_2D, oneByOneTexture);
            }
        } else if (texture == "galvanized") {
            if (galvanizedTexture.isFinished) {
           gl.bindTexture(gl.TEXTURE_2D, galvanizedTexture);
            } else{
                gl.bindTexture(gl.TEXTURE_2D, oneByOneTexture);
            }
        }
        gl.uniform1i(teapotShader.samplerUniform, 0);

        gl.uniform1f(teapotShader.materialShininessUniform, parseFloat(document.getElementById("shininess").value));
        var camMat = keyboardControls.getCamMatrix();
        gl.uniformMatrix4fv(teapotShader.camMatrix, false, camMat);
        gl.uniformMatrix4fv(teapotShader.frustum, false, frustum);

        for (var i = 0; i < ourObjects.length; i++) {
           drawModel(ourObjects[i]);
        }
        if (terrain != null && terrain.isFinished) {
            drawTerrain();
        }

        if(!once && terrain != null && terrain.isFinished && skyBox != null){
        console.log(terrain);
        // console.log(skyBox);
        once = true;
        }
    }

	function drawSkyBox(){
		gl.disable(gl.DEPTH_TEST);
		gl.useProgram(skyBoxShaders);
        var camMat = keyboardControls.getCamMatrix();
		var temp = mat4.clone(camMat);
		temp[12]=0;
		temp[13]=-0.5;
		temp[14]=0;

		gl.uniformMatrix4fv(skyBoxShaders.camMatrix, false, temp);
        gl.uniformMatrix4fv(skyBoxShaders.frustum, false, frustum);

		gl.activeTexture(gl.TEXTURE0);
        if (skyTexture.isFinished) {
                gl.bindTexture(gl.TEXTURE_2D, skyTexture);
            } else{
                gl.bindTexture(gl.TEXTURE_2D, oneByOneTexture);
            }
		gl.uniform1i(skyBoxShaders.samplerUniform, 0);
		
		gl.bindBuffer(gl.ARRAY_BUFFER,  skyBox.meshData.vertexBuffer);
        gl.vertexAttribPointer(skyBoxShaders.vertexPositionAttribute,  skyBox.meshData.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        if(! skyBox.meshData.textures.length){
            gl.disableVertexAttribArray(skyBoxShaders.textureCoordAttribute);
       } else {
            gl.enableVertexAttribArray(skyBoxShaders.textureCoordAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER,  skyBox.meshData.textureBuffer);
            gl.vertexAttribPointer(skyBoxShaders.textureCoordAttribute,  skyBox.meshData.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  skyBox.meshData.indexBuffer);

        gl.drawElements(gl.TRIANGLES,  skyBox.meshData.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		gl.enable(gl.DEPTH_TEST);
	}
	
    function drawModel(model) {
        gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.vertexBuffer);
        gl.vertexAttribPointer(teapotShader.vertexPositionAttribute,  model.meshData.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        if(! model.meshData.textures.length){
            gl.disableVertexAttribArray(teapotShader.textureCoordAttribute);
        } else {
            gl.enableVertexAttribArray(teapotShader.textureCoordAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER, model.meshData.textureBuffer);
            gl.vertexAttribPointer(teapotShader.textureCoordAttribute,  model.meshData.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }

        gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.normalBuffer);
        gl.vertexAttribPointer(teapotShader.vertexNormalAttribute,  model.meshData.normalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  model.meshData.indexBuffer);
        setMatrixUniforms(teapotShader, model);
        gl.drawElements(gl.TRIANGLES,  model.meshData.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }

    function drawTerrain(){
        gl.useProgram(terrainShader);
        var camMat = keyboardControls.getCamMatrix();
        gl.uniformMatrix4fv(terrainShader.camMatrix, false, camMat);
        // gl.uniformMatrix4fv(terrainShader.camMatrix, false, camMatrix);
        gl.uniformMatrix4fv(terrainShader.frustum, false, frustum);
        // now to render the mesh

        gl.activeTexture(gl.TEXTURE0);
        if (noiseBumpMap.isFinished) {
                gl.bindTexture(gl.TEXTURE_2D, noiseBumpMap);
            } else{
                gl.bindTexture(gl.TEXTURE_2D, oneByOneTexture);
        }
        gl.uniform1i(terrainShader.samplerUniform, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER,  terrain.vertexBuffer);
        gl.vertexAttribPointer(terrainShader.vertexPositionAttribute,  terrain.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

       //  if(!terrain.textures.length){
       //      gl.disableVertexAttribArray(terrainShader.textureCoordAttribute);
       // } else {
       //      gl.enableVertexAttribArray(terrainShader.textureCoordAttribute);
       //      gl.bindBuffer(gl.ARRAY_BUFFER,  terrain.textureBuffer);
       //      gl.vertexAttribPointer(terrainShader.textureCoordAttribute,  terrain.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
       //  }

        gl.bindBuffer(gl.ARRAY_BUFFER,  terrain.colorBuffer);
        gl.vertexAttribPointer(terrainShader.vertexColorAttribute,  terrain.colorBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER,  terrain.normalBuffer);
        gl.vertexAttribPointer(terrainShader.vertexNormalAttribute,  terrain.normalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  terrain.indexBuffer);

        // gl.uniformMatrix4fv(terrainShader.mvMatrixUniform, false, terrain.positionMatrix);
        setMatrixUniforms(terrainShader, terrain);

        gl.drawElements(gl.TRIANGLES,  terrain.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }
    var once = false;

    function tick() {
        requestAnimFrame(tick);
        keyboardControls.handleKeys(ourObjects);
        drawScene();
        keyboardControls.animate();
    }

    function loadObjects(){
        OBJ.downloadMeshes({
			'skyBox': 'objects/skybox.obj',
            'teapot': 'objects/teapot.obj',
            'eHouse': 'objects/simpleHouse.obj'
        }, webGLAddObj);
    }

    function webGLStart() {
        var canvas = document.getElementById("lesson14-canvas");
        initGL(canvas);
        initTextures();
        initShaders();
        mat4.perspective(frustum, 45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
        loadObjects();
        keyboardControls = new keyboardControls();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;

        tick();
    }

</script>

</head>

<body onload="webGLStart();">
    <canvas id="lesson14-canvas" style="border: none;" width="1000" height="500"></canvas>

    <br/>

    <input type="checkbox" id="specular" checked /> Show specular highlight<br/>
    <input type="checkbox" id="lighting" checked /> Use lighting<br/>

    Texture:
    <select id="texture">
        <option value="none">None</option>
        <option selected value="galvanized">Galvanized</option>
        <option value="earth">Earth</option>
    </select>
    <br/>

    <h2>Material:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Shininess:</b>
            <td><input type="text" id="shininess" value="32.0" />
        </tr>
    </table>

    <h2>Point light:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Location:</b>
            <td>X: <input type="text" id="lightPositionX" value="-10.0" />
            <td>Y: <input type="text" id="lightPositionY" value="4.0" />
            <td>Z: <input type="text" id="lightPositionZ" value="-20.0" />
        </tr>
        <tr>
            <td><b>Specular colour:</b>
            <td>R: <input type="text" id="specularR" value="0.8" />
            <td>G: <input type="text" id="specularG" value="0.8" />
            <td>B: <input type="text" id="specularB" value="0.8" />
        </tr>
        <tr>
            <td><b>Diffuse colour:</b>
            <td>R: <input type="text" id="diffuseR" value="0.8" />
            <td>G: <input type="text" id="diffuseG" value="0.8" />
            <td>B: <input type="text" id="diffuseB" value="0.8" />
        </tr>
    </table>

    <h2>Ambient light:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Colour:</b>
            <td>R: <input type="text" id="ambientR" value="0.2" />
            <td>G: <input type="text" id="ambientG" value="0.2" />
            <td>B: <input type="text" id="ambientB" value="0.2" />
        </tr>
    </table>
    <br/>
</body>

</html>
