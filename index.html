<html>

<head>
<title>Learning WebGL &mdash; lesson 1</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

  <link rel="stylesheet" href="css/app.css"/>

<script type="text/javascript" src="utils/jquery-1.11.2.min.js"></script>
<script type="text/javascript" src="utils/gl-matrix.js"></script>
<script type="text/javascript" src="utils/loadShaderUtil.js"></script>
<script type="text/javascript" src="utils/webgl-obj-loader.js"></script>
<script type="text/javascript" src="utils/webgl-utils.js"></script>
<script type="text/javascript" src="utils/terrain.js"></script>
<script type="text/javascript" src="utils/keyboardControls.js"></script>

<script type="text/javascript">

    var gl;
    var keyboardControls;
    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }
        function handleKeyDown(event) {
        keyboardControls.handleKeyDown(event);
    }

    function handleKeyUp(event) {
        keyboardControls.handleKeyUp(event);
    }
	
    var shaderProgram;
	var skyBoxShaders;
    var terrainShader;

    function setShaderProgramVars() {
        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

        shaderProgram.frustum = gl.getUniformLocation(shaderProgram, "frustum");
        shaderProgram.camMatrix = gl.getUniformLocation(shaderProgram, "camMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
        shaderProgram.materialShininessUniform = gl.getUniformLocation(shaderProgram, "uMaterialShininess");
        shaderProgram.showSpecularHighlightsUniform = gl.getUniformLocation(shaderProgram, "uShowSpecularHighlights");
        shaderProgram.useTexturesUniform = gl.getUniformLocation(shaderProgram, "uUseTextures");
        shaderProgram.useLightingUniform = gl.getUniformLocation(shaderProgram, "uUseLighting");
        shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientColor");
        shaderProgram.pointLightingLocationUniform = gl.getUniformLocation(shaderProgram, "uPointLightingLocation");
        shaderProgram.pointLightingSpecularColorUniform = gl.getUniformLocation(shaderProgram, "uPointLightingSpecularColor");
        shaderProgram.pointLightingDiffuseColorUniform = gl.getUniformLocation(shaderProgram, "uPointLightingDiffuseColor");
		
		//skybox
		gl.useProgram(skyBoxShaders);
		skyBoxShaders.vertexPositionAttribute = gl.getAttribLocation(skyBoxShaders, "aPosition");
        gl.enableVertexAttribArray(skyBoxShaders.vertexPositionAttribute);

        skyBoxShaders.vertexNormalAttribute = gl.getAttribLocation(skyBoxShaders, "aVertexNormal");
        gl.enableVertexAttribArray(skyBoxShaders.vertexNormalAttribute);

        skyBoxShaders.textureCoordAttribute = gl.getAttribLocation(skyBoxShaders, "aTexCoord");
        gl.enableVertexAttribArray(skyBoxShaders.textureCoordAttribute);

        //shaderProgram.frustum = gl.getUniformLocation(shaderProgram, "frustum");
        skyBoxShaders.mvMatrixUniform = gl.getUniformLocation(skyBoxShaders, "uMVMatrix");
        skyBoxShaders.nMatrixUniform = gl.getUniformLocation(skyBoxShaders, "uNMatrix");
        skyBoxShaders.camMatrix = gl.getUniformLocation(skyBoxShaders, "camMatrix");
        skyBoxShaders.samplerUniform = gl.getUniformLocation(skyBoxShaders, "uTexSky");
		
		gl.useProgram(shaderProgram);
    }

    function setTerrainShaderProgramVars() {
        gl.useProgram(terrainShader);

        terrainShader.vertexPositionAttribute = gl.getAttribLocation(terrainShader, "aVertexPosition");
        gl.enableVertexAttribArray(terrainShader.vertexPositionAttribute);

        //terrainShader.vertexNormalAttribute = gl.getAttribLocation(terrainShader, "aVertexNormal");
        //gl.enableVertexAttribArray(terrainShader.vertexNormalAttribute);

        terrainShader.vertexColorAttribute = gl.getAttribLocation(terrainShader, "aColorAttrib");
        gl.enableVertexAttribArray(terrainShader.vertexColorAttribute);

        terrainShader.frustum = gl.getUniformLocation(terrainShader, "frustum");
        terrainShader.camMatrix = gl.getUniformLocation(terrainShader, "camMatrix");
    }

    function initShaders() {

        shaderProgram = utils.addShaderProg(gl, 'teapot.vertex', 'teapot.frag');
        terrainShader = utils.addShaderProg(gl, 'terrain.vertex', 'terrain.frag');
		skyBoxShaders = utils.addShaderProg(gl, 'skyBox.vertex', 'skyBox.frag')

        setShaderProgramVars();
        setTerrainShaderProgramVars();

    }

    function handleLoadedTexture(texture) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);

        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    function handleLoadedHeightMap(texture) {
        gl.useProgram(terrainShader);
        terrain = new TerrainBlock(terrainHeightMap, 256, 256);
        terrain.isFinished = false;
        terrain.buildVertices();
        terrain.buildIndices();
        terrain.buildBuffers(gl);
    }

    var galvanizedTexture;
    var earthTexture;
	var skyTexture;
	var terrainHeightMap;

    function initTextures() {

        galvanizedTexture = gl.createTexture();
        galvanizedTexture.image = new Image();
        galvanizedTexture.image.onload = function () {
            handleLoadedTexture(galvanizedTexture)
        }
        galvanizedTexture.image.src = "textures/arroway.de_metal+structure+06_d100_flat.jpg";

        earthTexture = gl.createTexture();
        earthTexture.image = new Image();
        earthTexture.image.onload = function () {
            handleLoadedTexture(earthTexture)
        }
        earthTexture.image.src = "textures/earth.jpg";
		
		skyTexture = gl.createTexture();
        skyTexture.image = new Image();
        skyTexture.image.onload = function () {
            handleLoadedTexture(skyTexture)
        }
        skyTexture.image.src = "textures/earth.jpg";
		//skyTexture.image.onLoad.listen((e){console.log("image is loaded");});

        terrainHeightMap = new Image();
        terrainHeightMap.onload = function () {
            handleLoadedHeightMap(terrainHeightMap)
        }
        terrainHeightMap.src = "textures/fft-terrain.jpg";
        // terrainHeightMap.src = "textures/44-terrain.jpg";
    }

    var camMatrix = mat4.create();
    var frustum = mat4.create();

    function setMatrixUniforms(model) {
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, model.positionMatrix);

        var normalMatrix = mat3.create();
        mat3.fromMat4(normalMatrix, model.positionMatrix);
        mat3.invert(normalMatrix, normalMatrix);
        mat3.transpose(normalMatrix, normalMatrix);
        gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    var ourMeshes = {};
    var ourObjects = [];
	var ourBox = [];
    var terrain = {};

    function webGLAddObj(meshes){
        ourMeshes = meshes;
        OBJ.initMeshBuffers(gl, ourMeshes.teapot);
		OBJ.initMeshBuffers(gl, ourMeshes.skyBox);
        OBJ.initMeshBuffers(gl, ourMeshes.eHouse);
        createObjects();
    }

	var skyBox;
    function createObjects(){
        var teapot1, teapot2, mesh, skyBoxMesh, eHouse;
        mesh = ourMeshes.teapot;
		
        teapot1 = {name:"teapot1"};
        teapot1.meshData = mesh;
		teapot1.radius = 1;

        teapot2 = {name:"teapot2"};
        teapot2.meshData = mesh;
		teapot2.radius = 1;
		
		skyBoxMesh = ourMeshes.skyBox;
		
		skyBox = {name:"skyBox"};
		skyBox.meshData = skyBoxMesh;
		skyBox.radius = 5;
		
		var skyMat = mat4.create();
		mat4.identity(skyMat);
		skyBox.positionMatrix = skyMat; 
		ourBox.push(skyBox);
		
		teapot2.radius = 5;
        eHouse = {name: "eHouse"};
        eHouse.meshData = ourMeshes.eHouse;
        eHouse.radius = 1;

        var teapot1Mat = mat4.create(), teapot2Mat = mat4.create(), eHouseMat = mat4.create();

        mat4.identity(teapot1Mat);
        mat4.translate(teapot1Mat, teapot1Mat, [-10, 0, -40]);
        mat4.rotate(teapot1Mat, teapot1Mat, degToRad(23.4), [1, 0, -1]);
        mat4.rotate(teapot1Mat, teapot1Mat, degToRad(teapotAngle), [0, 1, 0]);
        teapot1.positionMatrix = teapot1Mat;
        ourObjects.push(teapot1);

        mat4.identity(teapot2Mat);
        mat4.translate(teapot2Mat, teapot2Mat, [10, 0, -40]);
        mat4.rotate(teapot2Mat, teapot2Mat, degToRad(-23.4), [1, 0, -1]);
        mat4.rotate(teapot2Mat, teapot2Mat, degToRad(-teapotAngle), [0, 1, 0]);
        teapot2.positionMatrix = teapot2Mat;
        ourObjects.push(teapot2);
		
        mat4.identity(eHouseMat);
        mat4.translate(eHouseMat, eHouseMat, [-10, 20, -40]);
        // mat4.rotate(eHouseMat, eHouseMat, degToRad(23.4), [1, 0, -1]);
        // mat4.rotate(eHouseMat, eHouseMat, degToRad(teapotAngle), [0, 1, 0]);
        eHouse.positionMatrix = eHouseMat;
        ourObjects.push(eHouse);
    }

    var teapotAngle = 180;

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		if(skyBox != null){
		drawSkyBox();
		}
		gl.useProgram(shaderProgram);
        
        var specularHighlights = document.getElementById("specular").checked;
        gl.uniform1i(shaderProgram.showSpecularHighlightsUniform, specularHighlights);

        var lighting = document.getElementById("lighting").checked;
        gl.uniform1i(shaderProgram.useLightingUniform, lighting);
        if (lighting) {
           gl.uniform3f(
               shaderProgram.ambientColorUniform,
               parseFloat(document.getElementById("ambientR").value),
               parseFloat(document.getElementById("ambientG").value),
               parseFloat(document.getElementById("ambientB").value)
           );

           gl.uniform3f(
               shaderProgram.pointLightingLocationUniform,
               parseFloat(document.getElementById("lightPositionX").value),
               parseFloat(document.getElementById("lightPositionY").value),
               parseFloat(document.getElementById("lightPositionZ").value)
           );

           gl.uniform3f(
               shaderProgram.pointLightingSpecularColorUniform,
               parseFloat(document.getElementById("specularR").value),
               parseFloat(document.getElementById("specularG").value),
               parseFloat(document.getElementById("specularB").value)
           );

           gl.uniform3f(
               shaderProgram.pointLightingDiffuseColorUniform,
               parseFloat(document.getElementById("diffuseR").value),
               parseFloat(document.getElementById("diffuseG").value),
               parseFloat(document.getElementById("diffuseB").value)
           );
        }

        var texture = document.getElementById("texture").value;
        gl.uniform1i(shaderProgram.useTexturesUniform, texture != "none");


        gl.activeTexture(gl.TEXTURE0);
        if (texture == "earth") {
           gl.bindTexture(gl.TEXTURE_2D, earthTexture);
        } else if (texture == "galvanized") {
           gl.bindTexture(gl.TEXTURE_2D, galvanizedTexture);
        }
        gl.uniform1i(shaderProgram.samplerUniform, 0);

        gl.uniform1f(shaderProgram.materialShininessUniform, parseFloat(document.getElementById("shininess").value));
        var camMat = keyboardControls.getCamMatrix();
        gl.uniformMatrix4fv(shaderProgram.camMatrix, false, camMat);
        // gl.uniformMatrix4fv(shaderProgram.camMatrix, false, camMatrix);
        gl.uniformMatrix4fv(shaderProgram.frustum, false, frustum);

        for (var i = 0; i < ourObjects.length; i++) {
           drawModel(ourObjects[i]);
        };
        if (terrain != null && terrain.isFinished) {
            drawTerrain();
        }

        if(!once && terrain != null && terrain.isFinished){
        console.log(terrain);
        once = true;
        }
    }

	function drawSkyBox(){
		gl.disable(gl.DEPTH_TEST);
		gl.useProgram(skyBoxShaders);
        gl.uniform1i(skyBoxShaders.useTexturesUniform, skyTexture != "none");
		var temp = mat4.clone(camMatrix);
		temp[3]=0;
		temp[7]=0;
		temp[11]=0;
		temp[15]=0;
		
		gl.uniformMatrix4fv(skyBoxShaders.camMatrix, false, temp);
		gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, skyTexture);
		gl.uniform1i(skyBoxShaders.samplerUniform, 0);
		
		gl.bindBuffer(gl.ARRAY_BUFFER,  skyBox.meshData.vertexBuffer);
        gl.vertexAttribPointer(skyBoxShaders.vertexPositionAttribute,  skyBox.meshData.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        if(! skyBox.meshData.textures.length){
			
            gl.disableVertexAttribArray(skyBoxShaders.textureCoordAttribute);
       } else {
            gl.enableVertexAttribArray(skyBoxShaders.textureCoordAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER,  skyBox.meshData.textureBuffer);
            gl.vertexAttribPointer(skyBoxShaders.textureCoordAttribute,  skyBox.meshData.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }

        gl.bindBuffer(gl.ARRAY_BUFFER,  skyBox.meshData.normalBuffer);
        gl.vertexAttribPointer(skyBoxShaders.vertexNormalAttribute,  skyBox.meshData.normalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  skyBox.meshData.indexBuffer);
        
		gl.uniformMatrix4fv(skyBoxShaders.mvMatrixUniform, false, skyBox.positionMatrix);
		
		var normalMatrix = mat3.create();
        mat3.fromMat4(normalMatrix, skyBox.positionMatrix);
  
        gl.uniformMatrix3fv(skyBoxShaders.nMatrixUniform, false, normalMatrix);
        gl.drawElements(gl.TRIANGLES,  skyBox.meshData.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		gl.enable(gl.DEPTH_TEST);
	}
	
    function drawModel(model) {
        // now to render the mesh
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.vertexBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,  model.meshData.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        if(! model.meshData.textures.length){
            gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
        } else {
            gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.textureBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute,  model.meshData.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }

        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
        gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.normalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute,  model.meshData.normalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  model.meshData.indexBuffer);
        setMatrixUniforms(model);
        gl.drawElements(gl.TRIANGLES,  model.meshData.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }

    function drawTerrain(){
        gl.useProgram(terrainShader);
        var camMat = keyboardControls.getCamMatrix();
        gl.uniformMatrix4fv(terrainShader.camMatrix, false, camMat);
        // gl.uniformMatrix4fv(terrainShader.camMatrix, false, camMatrix);
        gl.uniformMatrix4fv(terrainShader.frustum, false, frustum);
        // now to render the mesh

        gl.bindBuffer(gl.ARRAY_BUFFER,  terrain.vertexBuffer);
        gl.vertexAttribPointer(terrainShader.vertexPositionAttribute,  terrain.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER,  terrain.colorBuffer);
        gl.vertexAttribPointer(terrainShader.vertexColorAttribute,  terrain.colorBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //gl.bindBuffer(gl.ARRAY_BUFFER,  terrain.normalBuffer);
        //gl.vertexAttribPointer(terrainShader.vertexNormalAttribute,  terrain.normalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  terrain.indexBuffer);
        //setMatrixUniforms(terrain);

        gl.drawElements(gl.TRIANGLES,  terrain.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }
    var once = false;

    function tick() {
        requestAnimFrame(tick);
        keyboardControls.handleKeys(ourObjects);
        drawScene();
        keyboardControls.animate();
    }

    function loadObjects(){
        OBJ.downloadMeshes({
              
			'skyBox': 'objects/skybox.obj',
            'teapot': 'objects/teapot.obj',
            'eHouse': 'objects/emilHouse.obj'
        }, webGLAddObj);
    }

    function webGLStart() {
        var canvas = document.getElementById("lesson14-canvas");
        initGL(canvas);
        mat4.perspective(frustum, 45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
        loadObjects();
        initShaders();
        initTextures();
        mat4.identity(camMatrix);
        keyboardControls = new keyboardControls();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;

        tick();
    }

</script>

</head>

<body onload="webGLStart();">
    <canvas id="lesson14-canvas" style="border: none;" width="1000" height="500"></canvas>

    <br/>

    <input type="checkbox" id="specular" checked /> Show specular highlight<br/>
    <input type="checkbox" id="lighting" checked /> Use lighting<br/>

    Texture:
    <select id="texture">
        <option value="none">None</option>
        <option selected value="galvanized">Galvanized</option>
        <option value="earth">Earth</option>
    </select>
    <br/>

    <h2>Material:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Shininess:</b>
            <td><input type="text" id="shininess" value="32.0" />
        </tr>
    </table>

    <h2>Point light:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Location:</b>
            <td>X: <input type="text" id="lightPositionX" value="-10.0" />
            <td>Y: <input type="text" id="lightPositionY" value="4.0" />
            <td>Z: <input type="text" id="lightPositionZ" value="-20.0" />
        </tr>
        <tr>
            <td><b>Specular colour:</b>
            <td>R: <input type="text" id="specularR" value="0.8" />
            <td>G: <input type="text" id="specularG" value="0.8" />
            <td>B: <input type="text" id="specularB" value="0.8" />
        </tr>
        <tr>
            <td><b>Diffuse colour:</b>
            <td>R: <input type="text" id="diffuseR" value="0.8" />
            <td>G: <input type="text" id="diffuseG" value="0.8" />
            <td>B: <input type="text" id="diffuseB" value="0.8" />
        </tr>
    </table>

    <h2>Ambient light:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Colour:</b>
            <td>R: <input type="text" id="ambientR" value="0.2" />
            <td>G: <input type="text" id="ambientG" value="0.2" />
            <td>B: <input type="text" id="ambientB" value="0.2" />
        </tr>
    </table>
    <br/>
</body>

</html>
