<html>

<head>
<title>Dungeons And Terrains</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

  <link rel="stylesheet" href="css/app.css"/>

<script type="text/javascript" src="utils/jquery-1.11.2.min.js"></script>
<script type="text/javascript" src="utils/gl-matrix.js"></script>
<script type="text/javascript" src="utils/loadShaderUtil.js"></script>
<script type="text/javascript" src="utils/webgl-obj-loader.js"></script>
<script type="text/javascript" src="utils/webgl-utils.js"></script>
<script type="text/javascript" src="utils/terrain.js"></script>
<script type="text/javascript" src="utils/keyboardControls.js"></script>

<script type="text/javascript">

    var gl;
    var keyboardControls;
    var lightMat;
    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.getExtension('OES_standard_derivatives');
            gl.getExtension('WEBGL_depth_texture');
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    function handleKeyDown(event) {
        keyboardControls.handleKeyDown(event);
    }

    function handleKeyUp(event) {
        keyboardControls.handleKeyUp(event);
    }
	
    var teapotShader;
	var skyBoxShaders;
    var terrainShader;
	var billBoardShaders;
    var crateShader;
    var lightSourceShaders;
    var simpleShader;
    var outerTerrainShader;
    var depthFBO;
    var depthTexture;

    // function createFBOAndTexture(){
    //     depthTexture = gl.createTexture();
    //     depthTexture.width = 521;
    //     depthTexture.height = 512;
    //     gl.bindTexture(gl.TEXTURE_2D, depthTexture);
    //     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    //     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    //     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    //     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    //     gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, depthTexture.width, depthTexture.height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);

    //     depthFBO = gl.createFramebuffer();
    //     gl.bindFramebuffer(gl.FRAMEBUFFER, depthFBO);
    //     gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
    // }
    function createFBOAndTexture(){
        depthFBO=gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, depthFBO);

        var rb=gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, rb);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16 , 512, 512);

        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
                             gl.RENDERBUFFER, rb);

        depthTexture=gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, depthTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 512, 512,
                0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
                          gl.TEXTURE_2D, depthTexture, 0);

        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    function setSimpleShaderVars(){
        gl.useProgram(simpleShader);

        simpleShader.vertexPositionAttribute = gl.getAttribLocation(simpleShader, "aVertexPosition");
        gl.enableVertexAttribArray(simpleShader.vertexPositionAttribute);

        simpleShader.projection = gl.getUniformLocation(simpleShader, "projection");
        simpleShader.camMatrix = gl.getUniformLocation(simpleShader, "camMatrix");
    }

    function setTeapotShaderProgramVars() {
        gl.useProgram(teapotShader);

        teapotShader.vertexPositionAttribute = gl.getAttribLocation(teapotShader, "aVertexPosition");
        gl.enableVertexAttribArray(teapotShader.vertexPositionAttribute);

        teapotShader.vertexNormalAttribute = gl.getAttribLocation(teapotShader, "aVertexNormal");
        gl.enableVertexAttribArray(teapotShader.vertexNormalAttribute);

        teapotShader.textureCoordAttribute = gl.getAttribLocation(teapotShader, "aTextureCoord");
        gl.enableVertexAttribArray(teapotShader.textureCoordAttribute);

        teapotShader.projection = gl.getUniformLocation(teapotShader, "projection");
        teapotShader.camMatrix = gl.getUniformLocation(teapotShader, "camMatrix");
        teapotShader.mvMatrixUniform = gl.getUniformLocation(teapotShader, "uMVMatrix");
        teapotShader.nMatrixUniform = gl.getUniformLocation(teapotShader, "uNMatrix");
        teapotShader.samplerUniform = gl.getUniformLocation(teapotShader, "uSampler");
        teapotShader.materialShininessUniform = gl.getUniformLocation(teapotShader, "uMaterialShininess");
        teapotShader.showSpecularHighlightsUniform = gl.getUniformLocation(teapotShader, "uShowSpecularHighlights");
        teapotShader.useLightingUniform = gl.getUniformLocation(teapotShader, "uUseLighting");
        teapotShader.ambientColorUniform = gl.getUniformLocation(teapotShader, "uAmbientColor");
        teapotShader.pointLightingLocationUniform = gl.getUniformLocation(teapotShader, "uPointLightingLocation");
        teapotShader.pointLightingSpecularColorUniform = gl.getUniformLocation(teapotShader, "uPointLightingSpecularColor");
        teapotShader.pointLightingDiffuseColorUniform = gl.getUniformLocation(teapotShader, "uPointLightingDiffuseColor");
    }

    function setskyBoxShaderProgramVars(){
        gl.useProgram(skyBoxShaders);

        skyBoxShaders.vertexPositionAttribute = gl.getAttribLocation(skyBoxShaders, "aVertexPosition");
        gl.enableVertexAttribArray(skyBoxShaders.vertexPositionAttribute);

        skyBoxShaders.textureCoordAttribute = gl.getAttribLocation(skyBoxShaders, "aTexCoord");
        gl.enableVertexAttribArray(skyBoxShaders.textureCoordAttribute);

        skyBoxShaders.camMatrix = gl.getUniformLocation(skyBoxShaders, "camMatrix");
        skyBoxShaders.projection = gl.getUniformLocation(skyBoxShaders, "projection");
        skyBoxShaders.samplerUniform = gl.getUniformLocation(skyBoxShaders, "uTexSky");
        skyBoxShaders.mvMatrixUniform = gl.getUniformLocation(skyBoxShaders, "uMVMatrix");
    }

    function setTerrainShaderProgramVars() {
        gl.useProgram(terrainShader);

        terrainShader.vertexPositionAttribute = gl.getAttribLocation(terrainShader, "aVertexPosition");
        gl.enableVertexAttribArray(terrainShader.vertexPositionAttribute);

        terrainShader.vertexNormalAttribute = gl.getAttribLocation(terrainShader, "aVertexNormal");
        gl.enableVertexAttribArray(terrainShader.vertexNormalAttribute);

        terrainShader.vertexColorAttribute = gl.getAttribLocation(terrainShader, "aColorAttrib");
        gl.enableVertexAttribArray(terrainShader.vertexColorAttribute);

        terrainShader.mvMatrixUniform = gl.getUniformLocation(terrainShader, "uMVMatrix");
        terrainShader.projection = gl.getUniformLocation(terrainShader, "projection");
        terrainShader.camMatrix = gl.getUniformLocation(terrainShader, "camMatrix");
        terrainShader.samplerUniform = gl.getUniformLocation(terrainShader, "uTexBump");
        terrainShader.nMatrixUniform = gl.getUniformLocation(terrainShader, "uNMatrix");
        terrainShader.shadowTex = gl.getUniformLocation(terrainShader, "shadowTex");
        terrainShader.lightMatrix = gl.getUniformLocation(terrainShader, "lightMatrix");
        terrainShader.lightProjection = gl.getUniformLocation(terrainShader, "lightProjection");
        terrainShader.pointLightingLocationUniform = gl.getUniformLocation(terrainShader, "uPointLightingLocation");
    }
	
	function setouterTerrainShaderProgramVars() {
        gl.useProgram(outerTerrainShader);

        outerTerrainShader.vertexPositionAttribute = gl.getAttribLocation(outerTerrainShader, "aVertexPosition");
        gl.enableVertexAttribArray(outerTerrainShader.vertexPositionAttribute);

        outerTerrainShader.mvMatrixUniform = gl.getUniformLocation(outerTerrainShader, "uMVMatrix");
        outerTerrainShader.frustum = gl.getUniformLocation(outerTerrainShader, "frustum");
        outerTerrainShader.camMatrix = gl.getUniformLocation(outerTerrainShader, "camMatrix");
        outerTerrainShader.samplerUniform = gl.getUniformLocation(outerTerrainShader, "uTexBump");
      
		outerTerrainShader.textureCoordAttribute = gl.getAttribLocation(outerTerrainShader, "aTextureCoord");
        gl.enableVertexAttribArray(outerTerrainShader.textureCoordAttribute);
    }

    function setCrateShaderProgramVars() {
        gl.useProgram(crateShader);

        crateShader.vertexPositionAttribute = gl.getAttribLocation(crateShader, "aVertexPosition");
        gl.enableVertexAttribArray(crateShader.vertexPositionAttribute);

        crateShader.vertexNormalAttribute = gl.getAttribLocation(crateShader, "aVertexNormal");
        gl.enableVertexAttribArray(crateShader.vertexNormalAttribute);

        crateShader.textureCoordAttribute = gl.getAttribLocation(crateShader, "aTextureCoord");
        gl.enableVertexAttribArray(crateShader.textureCoordAttribute);

        crateShader.projection = gl.getUniformLocation(crateShader, "projection");
        crateShader.camMatrix = gl.getUniformLocation(crateShader, "camMatrix");
        crateShader.mvMatrixUniform = gl.getUniformLocation(crateShader, "uMVMatrix");
        crateShader.nMatrixUniform = gl.getUniformLocation(crateShader, "uNMatrix");
        crateShader.samplerUniform = gl.getUniformLocation(crateShader, "uSampler");
        crateShader.bumpMap = gl.getUniformLocation(crateShader, "bumpMap");
        crateShader.lightSources = gl.getUniformLocation(crateShader, "ulightSources");
        crateShader.amountOfLightSources = gl.getUniformLocation(crateShader, "uAmountOfLightSources");
    }

	function setBillBoardShaderProgramVars() {
        gl.useProgram(billBoardShaders);

        billBoardShaders.vertexPositionAttribute = gl.getAttribLocation(billBoardShaders, "aVertexPosition");
        gl.enableVertexAttribArray(billBoardShaders.vertexPositionAttribute);

        //billBoardShaders.vertexNormalAttribute = gl.getAttribLocation(billBoardShaders, "aVertexNormal");
        //gl.enableVertexAttribArray(billBoardShaders.vertexNormalAttribute);

        billBoardShaders.textureCoordAttribute = gl.getAttribLocation(billBoardShaders, "aTextureCoord");
        gl.enableVertexAttribArray(billBoardShaders.textureCoordAttribute);

        billBoardShaders.frustum = gl.getUniformLocation(billBoardShaders, "frustum");
        billBoardShaders.camMatrix = gl.getUniformLocation(billBoardShaders, "camMatrix");
        billBoardShaders.mvMatrixUniform = gl.getUniformLocation(billBoardShaders, "uMVMatrix");
        billBoardShaders.samplerUniform = gl.getUniformLocation(billBoardShaders, "uTexBill");
		billBoardShaders.RMatrixUniform = gl.getUniformLocation(billBoardShaders, "uRMatrix");

    }

    function setLightSourceShaderVars(){
        gl.useProgram(lightSourceShaders);

        lightSourceShaders.vertexPositionAttribute = gl.getAttribLocation(lightSourceShaders, "aVertexPosition");
        gl.enableVertexAttribArray(lightSourceShaders.vertexPositionAttribute);

        lightSourceShaders.camMatrix = gl.getUniformLocation(lightSourceShaders, "camMatrix");
        lightSourceShaders.projection = gl.getUniformLocation(lightSourceShaders, "projection");
        lightSourceShaders.mvMatrixUniform = gl.getUniformLocation(lightSourceShaders, "uMVMatrix");
    }

    function initShaders() {

        teapotShader = utils.addShaderProg(gl, 'teapot.vertex', 'teapot.frag');
        terrainShader = utils.addShaderProg(gl, 'terrain.vertex', 'terrain.frag');
		outerTerrainShader = utils.addShaderProg(gl, 'terrain2.vertex', 'terrain2.frag');
		skyBoxShaders = utils.addShaderProg(gl, 'skyBox.vertex', 'skyBox.frag');
		billBoardShaders = utils.addShaderProg(gl, 'billBoard.vertex', 'billBoard.frag');
        crateShader = utils.addShaderProg(gl, "crateShader.vertex", "crateShader.frag");
        lightSourceShaders = utils.addShaderProg(gl, "lightSource.vertex", "lightSource.frag");
        simpleShader = utils.addShaderProg(gl, "plain.vertex", "plain.frag");
        setTeapotShaderProgramVars();
        setTerrainShaderProgramVars();
		setouterTerrainShaderProgramVars();
        setskyBoxShaderProgramVars();
		setBillBoardShaderProgramVars();
        setCrateShaderProgramVars();
        setLightSourceShaderVars();
        setSimpleShaderVars();

    }

    function handleLoadedTexture(texture) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.bindTexture(gl.TEXTURE_2D, null);
        texture.isFinished = true;
    }

    function handleLoadedHeightMap(texture) {
        gl.useProgram(terrainShader);
        terrain = new TerrainBlock(terrainHeightMap, 256, 256, 256, 256);
        terrain.isFinished = false;
        terrain.shader = terrainShader;

        var pos = mat4.create();
        mat4.identity(pos);
        mat4.translate(pos, pos, [ -80, -15, -80]);

        terrain.positionMatrix = pos;
        terrain.buildVertices();
        terrain.buildIndices();
        terrain.buildBuffers(gl);
		
    }

    var galvanizedTexture;
    var earthTexture;
	var skyTexture;
    var cloudTexture1;
    var cloudTexture2;
    var cloudTexture3;
	var terrainHeightMap;
    var oneByOneTexture;
	var billBoardTexture;
    var noiseBumpMap;
    var crateTexture;
	var grassTexture;

    function initTextures() {

        oneByOneTexture = setUpTextures(oneByOneTexture, "1x1.jpg");
        galvanizedTexture = setUpTextures(galvanizedTexture, "arroway.de_metal+structure+06_d100_flat.jpg");
        noiseBumpMap = setUpTextures(noiseBumpMap, "noise.jpg");
        earthTexture = setUpTextures(earthTexture, "earth.jpg");
        skyTexture = setUpTextures(skyTexture, "SkyBox512.jpg");
        cloudTexture1 = setUpTextures(cloudTexture1, "cloudTex1.png");
        cloudTexture2 = setUpTextures(cloudTexture2, "cloudTex2.png");
        cloudTexture3 = setUpTextures(cloudTexture3, "cloudTex3.png");
        crateTexture = setUpTextures(crateTexture, "crate.gif");
		billBoardTexture = setUpTextures(billBoardTexture, "tree2.png");
		grassTexture = setUpTextures(grassTexture, "grass.jpg");
        terrainHeightMap = new Image();
        terrainHeightMap.onload = function () {
            handleLoadedHeightMap(terrainHeightMap)
        }
        terrainHeightMap.src = "textures/fft-terrain.jpg";
		
        // terrainHeightMap.src = "textures/44-terrain.jpg";
		
		
    }

    function setUpTextures(textureVarName, picture){
        textureVarName = gl.createTexture();
        textureVarName.isFinished = false;
        textureVarName.image = new Image();
        textureVarName.image.onload = function () {
            handleLoadedTexture(textureVarName)
        }
        textureVarName.image.src = "textures/"+picture;
        return textureVarName;
    }

    var projection = mat4.create();
    var lightProjection = mat4.create();

    function setMatrixUniforms(model) {
        if (model.movable) {
            var temp = keyboardControls.getObjPos();
            // console.log(temp)
            mat4.multiply(temp, model.positionMatrix, temp);
            // console.log(temp)
            gl.uniformMatrix4fv(model.shader.mvMatrixUniform, false, temp);
        }else{
            gl.uniformMatrix4fv(model.shader.mvMatrixUniform, false, model.positionMatrix);
        }

        if(model.shader.nMatrixUniform != null) {
            var normalMatrix = mat3.create();
            mat3.fromMat4(normalMatrix, model.positionMatrix);
            mat3.invert(normalMatrix, normalMatrix);
            mat3.transpose(normalMatrix, normalMatrix);
            gl.uniformMatrix3fv(model.shader.nMatrixUniform, false, normalMatrix);
        }
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    var ourMeshes = {};
    var ourObjects = [];
    var houseLightSources = [];
    var terrain = {};
    var skyBoxes = [];
    var outerTerrain;

    function webGLAddObj(meshes){
        ourMeshes = meshes;
        OBJ.initMeshBuffers(gl, ourMeshes.teapot);
		OBJ.initMeshBuffers(gl, ourMeshes.skyBox);
        OBJ.initMeshBuffers(gl, ourMeshes.cubePlus);
        OBJ.initMeshBuffers(gl, ourMeshes.cubePlusMedium);
        OBJ.initMeshBuffers(gl, ourMeshes.rectanglePlusMedium);
        OBJ.initMeshBuffers(gl, ourMeshes.rectanglePlusMedium2);
        OBJ.initMeshBuffers(gl, ourMeshes.eHouse);
		OBJ.initMeshBuffers(gl, ourMeshes.billBoard);
		OBJ.initMeshBuffers(gl, ourMeshes.outerTerrain);
        OBJ.initMeshBuffers(gl, ourMeshes.lamp);
        createBillboard();
		createObjects();
		
    }

    function createObjects(){
        var teapot1, teapot2, eHouse, skyBox, cloudBox1, cloudBox2, cloudBox3, crate, crate2, crate3, crate4, lightSource1, lightSource2, lightSource3;

        teapot1 = {name:"teapot1"};
        teapot1.meshData = ourMeshes.teapot;
        teapot1.texture = galvanizedTexture;
        teapot1.hasBumpMap = false;
		teapot1.radius = 10;
        teapot1.movable = false;
        teapot1.shader = teapotShader;

        teapot2 = {name:"teapot2"};
        teapot2.meshData = ourMeshes.teapot;
        teapot2.texture = earthTexture;
        teapot2.hasBumpMap = false;
		teapot2.radius = 10;
        teapot2.movable = false;
        teapot2.shader = teapotShader;

        cloudBox1 = {name:"cloudBox1"};
        cloudBox1.meshData = ourMeshes.skyBox;
        cloudBox1.texture = cloudTexture1;
        cloudBox1.movable = false;
        cloudBox1.shader = skyBoxShaders;

        cloudBox2 = {name:"cloudBox2"};
        cloudBox2.meshData = ourMeshes.skyBox;
        cloudBox2.texture = cloudTexture2;
        cloudBox2.movable = false;
        cloudBox2.shader = skyBoxShaders;

        cloudBox3 = {name:"cloudBox3"};
        cloudBox3.meshData = ourMeshes.skyBox;
        cloudBox3.texture = cloudTexture3;
        cloudBox3.movable = false;
        cloudBox3.shader = skyBoxShaders;

        skyBox = {name:"skyBox"};
        skyBox.meshData = ourMeshes.skyBox;
        skyBox.texture = skyTexture;
        skyBox.movable = false;
        skyBox.shader = skyBoxShaders;

        eHouse = {name: "eHouse"};
        eHouse.meshData = ourMeshes.eHouse;
        eHouse.texture = galvanizedTexture;
        eHouse.hasBumpMap = false;
        eHouse.radius = 1;

		outerTerrain = {name:"outerTerrain"};
		outerTerrain.meshData = ourMeshes.outerTerrain;
		outerTerrain.radius = 1;
		outerTerrain.shader = outerTerrainShader;
		outerTerrain.texture = grassTexture;

        eHouse.movable = false;
        eHouse.shader = teapotShader;

        crate = {name: "crate"};
        crate.meshData = ourMeshes.cubePlusMedium;
        crate.texture = crateTexture;
        crate.hasBumpMap = true;
        crate.radius = 1;
        crate.movable = false;
        crate.shader = crateShader;

        crate2 = {name: "crate2"};
        crate2.meshData = ourMeshes.rectanglePlusMedium;
        crate2.texture = crateTexture;
        crate2.hasBumpMap = true;
        crate2.radius = 1;
        crate2.movable = false;
        crate2.shader = crateShader;


        crate3 = {name: "crate3"};
        crate3.meshData = ourMeshes.rectanglePlusMedium2;
        crate3.texture = crateTexture;
        crate3.bumpMap = noiseBumpMap;
        crate3.hasBumpMap = true;
        crate3.radius = 1;
        crate3.movable = false;
        crate3.shader = crateShader;

        crate4 = {name: "crate4"};
        crate4.meshData = ourMeshes.cubePlusMedium;
        crate4.texture = crateTexture;
        crate4.bumpMap = noiseBumpMap;
        crate4.hasBumpMap = true;
        crate4.radius = 1;
        crate4.movable = false;
        crate4.shader = crateShader;

        lightSource1 = {name: "lightSource1"};
        lightSource1.meshData = ourMeshes.lamp;
        lightSource1.texture = crateTexture;
        lightSource1.radius = 0.5;
        lightSource1.movable = false;
        lightSource1.shader = lightSourceShaders;

        lightSource2 = {name: "lightSource2"};
        lightSource2.meshData = ourMeshes.lamp;
        lightSource2.texture = crateTexture;
        lightSource2.radius = 0.5;
        lightSource2.movable = false;
        lightSource2.shader = lightSourceShaders;

        lightSource3 = {name: "lightSource3"};
        lightSource3.meshData = ourMeshes.lamp;
        lightSource3.texture = crateTexture;
        lightSource3.radius = 0.5;
        lightSource3.movable = false;
        lightSource3.shader = lightSourceShaders;


        var posMat = mat4.create();
        mat4.identity(posMat);

        skyBox.positionMatrix = mat4.clone(posMat);
        cloudBox1.positionMatrix = mat4.clone(posMat);
        cloudBox2.positionMatrix = mat4.clone(posMat);
        cloudBox3.positionMatrix = mat4.clone(posMat);
        cloudBox1.rotVec = {x:1, y:1, z:1};
        cloudBox1.rotSpeed = 0.0002;
        cloudBox2.rotVec = {x:1, y:-1, z:-1};
        cloudBox2.rotSpeed = 0.0004;
        cloudBox3.rotVec = {x:-1, y:-1, z:1};
        cloudBox3.rotSpeed = 0.0003;

        skyBoxes.push(skyBox);
        skyBoxes.push(cloudBox3);
        skyBoxes.push(cloudBox2);
        skyBoxes.push(cloudBox1);

        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [-10, 0, -40]);
        mat4.rotate(posMat, posMat, degToRad(23.4), [1, 0, -1]);
        mat4.rotate(posMat, posMat, degToRad(teapotAngle), [0, 1, 0]);
        teapot1.positionMatrix = mat4.clone(posMat);
        //ourObjects.push(teapot1);

        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [10, 0, -40]);
        mat4.rotate(posMat, posMat, degToRad(-23.4), [1, 0, -1]);
        mat4.rotate(posMat, posMat, degToRad(-teapotAngle), [0, 1, 0]);
        teapot2.positionMatrix = mat4.clone(posMat);
        //ourObjects.push(teapot2);
	
		mat4.identity(posMat);
        mat4.translate(posMat, posMat, [-250, -16, 500]);
        outerTerrain.positionMatrix = mat4.clone(posMat);
    
        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [-10, -15, 30]);
        mat4.rotate(posMat, posMat, degToRad(0), [0, 1, 0]);
        eHouse.positionMatrix = mat4.clone(posMat);
        ourObjects.push(eHouse);

        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [-10.6658, -8.7546, 16.8532]);
        lightSource1.positionMatrix = mat4.clone(posMat);
        houseLightSources.push(lightSource1);

        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [10.8099, -8.7546, 19.33]);
        lightSource2.positionMatrix = mat4.clone(posMat);
        houseLightSources.push(lightSource2);

        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [0, -8.7546, 4]);
        lightSource3.positionMatrix = mat4.clone(posMat);
        houseLightSources.push(lightSource3);

        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [-14.9331, -13.3361, 19.3915]);
        mat4.rotate(posMat, posMat, degToRad(0), [0, 1, 0]);
        crate.positionMatrix = mat4.clone(posMat);
        crate.lightSources = [];
        crate.lightSources.push(lightSource1);
        ourObjects.push(crate);

        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [16.4274, -13.3361, 21.4712]);
        mat4.rotate(posMat, posMat, degToRad(90), [0, 1, 0]);
        crate2.positionMatrix = mat4.clone(posMat);
        crate2.lightSources = [];
        crate2.lightSources.push(lightSource2);
        ourObjects.push(crate2);

        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [-5.2840, -11.8361, 9.5395]);
        mat4.rotate(posMat, posMat, degToRad(180), [1, 1, 0]);
        mat4.rotate(posMat, posMat, 1.06, [1, 0, 0]);
        crate3.positionMatrix = mat4.clone(posMat);
        crate3.lightSources = [];
        crate3.lightSources.push(lightSource3);
        ourObjects.push(crate3);

        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [0, -13.3361, 9.5395]);
        crate4.positionMatrix = mat4.clone(posMat);
        crate4.lightSources = [];
        crate4.lightSources.push(lightSource1);
        crate4.lightSources.push(lightSource2);
        crate4.lightSources.push(lightSource3);
        ourObjects.push(crate4);

		//createBillboard();
    }
	
	var billBoards = [];
	function createBillboard(){
	
		var billPos = mat4.create();
		var newPos = mat4.create();
		mat4.identity(billPos);
		mat4.translate(billPos, billPos, [0, -16, 0]);
		for (var i = 0; i < 10; i++) {
			newPos = mat4.clone(billPos);
			var random = Math.random() *50;
			if(Math.random < 0.5){
			mat4.translate(newPos, newPos, [200+random, 0,i*10]);
			}else{
			mat4.translate(newPos, newPos, [200-random, 0,i*10]);
			}
			 mat4.rotate(newPos, newPos, degToRad(90), [0, 1, 0]);
			
		  // newPos = mat4.clone(billPos);
		   var billBoard = {name:"billBoard"};
		  
			billBoard.meshData = ourMeshes.billBoard;
			billBoard.positionMatrix = newPos;
			billBoard.texture = billBoardTexture;
			billBoard.shader = billBoardShaders;
			billBoards.push(billBoard);
        }
		
			for (var i = 0; i < 10; i++) {
			newPos = mat4.clone(billPos);
			var random = Math.random() *50;
			if(Math.random < 0.5){
			mat4.translate(newPos, newPos, [i*10, 0,200+random]);
			}else{
			mat4.translate(newPos, newPos, [i*10, 0,200-random]);
			}
			 
		   var billBoard = {name:"billBoard"};
		  
			billBoard.meshData = ourMeshes.billBoard;
			billBoard.positionMatrix = newPos;
			billBoard.texture = billBoardTexture;
			billBoard.shader = billBoardShaders;
			billBoards.push(billBoard);
        }
			for (var i = 0; i < 10; i++) {
			newPos = mat4.clone(billPos);
			var random = Math.random() *50;
			if(Math.random < 0.5){
			mat4.translate(newPos, newPos, [-200+random, 0,i*10]);
			}else{
			mat4.translate(newPos, newPos, [-200-random, 0,i*10]);
			}
			 mat4.rotate(newPos, newPos, degToRad(-90), [0, 1, 0]);
			
		  // newPos = mat4.clone(billPos);
		   var billBoard = {name:"billBoard"};
		  
			billBoard.meshData = ourMeshes.billBoard;
			billBoard.positionMatrix = newPos;
			billBoard.texture = billBoardTexture;
			billBoard.shader = billBoardShaders;
			billBoards.push(billBoard);
        }
		
		
	}

    var teapotAngle = 180;

    function drawScene() {
        getHTMLVars();
        gl.bindFramebuffer(gl.FRAMEBUFFER, depthFBO);
        drawSceneForShadows();
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.cullFace(gl.BACK);

        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
		drawSkyBoxes();
        if (outerTerrain != null) {
            drawTerrain2();
        }
		drawBillBoards();
		drawObjects();

        if (terrain != null && terrain.isFinished) {
            drawTerrain();
        }
    }

    function drawSceneForShadows(){
        gl.viewport(0, 0, 512, 512);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.clearColor(1.0, 0.0, 0.0, 1.0);
        gl.cullFace(gl.FRONT);

        gl.useProgram(simpleShader);
        lookAt();
        for (var i = 0; i < ourObjects.length; i++) {
           drawSimpleModel(ourObjects[i]);
        }
    }

    function drawSimpleModel(model){
        gl.uniformMatrix4fv(simpleShader.projection, false, lightProjection);
        gl.uniformMatrix4fv(simpleShader.camMatrix, false, lightMat);

        gl.bindBuffer(gl.ARRAY_BUFFER, model.meshData.vertexBuffer);
        gl.vertexAttribPointer(simpleShader.vertexPositionAttribute, model.meshData.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.meshData.indexBuffer);
        gl.drawElements(gl.TRIANGLES, model.meshData.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }

    var lightLocation;
    var ifLighting;
    var lightColor;
    var speccColor;
    var diffuseColor;
    var specularHighlights;
    var shininess;

    function drawObjects(){
        for (var i = 0; i < ourObjects.length; i++) {
           drawModel(ourObjects[i]);
        }
        for (var i = 0; i < houseLightSources.length; i++) {
           drawModel(houseLightSources[i]);
        }
    }

	function getModelDirection(posMatrix, camMatrix){
        var pos = mat4.create();
		
        mat4.multiply(pos, camMatrix, posMatrix);
        var posVec = vec3.create();
		var length = Math.sqrt(pos[12]*pos[12]+pos[13]*pos[13]+pos[14]*pos[14]);
		
        posVec[0] = pos[12]/length;
        posVec[1] = pos[13]/length;
        posVec[2] = pos[14]/length;
        return posVec;
    }
	function drawBillBoards(){
		gl.useProgram(billBoardShaders);
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
		
        gl.disable(gl.DEPTH_TEST);
		for (var i = 0; i < billBoards.length; i++) {
		//for (var i = 0; i < 1; i++) {
            if(billBoards[i] != null){
                drawBillboard(billBoards[i]);
            }
        }
		gl.disable(gl.BLEND);
       gl.enable(gl.DEPTH_TEST);
		
	}
	
	function drawBillboard(board){
		 var totRot;
        var camMat = keyboardControls.getCamMatrix();
		var directionFromModel = getModelDirection(board.positionMatrix, camMat);
		
		var total = mat4.create();
		//total = mat4.multiply(total, camMat, board.positionMatrix);
 
		directionFromModel[1] = 0; //zero the y
		
		
		var cosa = directionFromModel[2];
		var direction = vec3.create();
		var lookAt = vec3.create();
		lookAt[2] = -1;
		vec3.cross(direction, directionFromModel,lookAt);
		
		var rotation = Math.acos(cosa)*180/Math.PI;
		rotation = degToRad(rotation);
		var totRot = mat4.create();
		mat4.identity(totRot);
		
		if(direction[1] < 0 ){
		// console.log("rot was: "+rotation);
		rotation = Math.PI - rotation;
		// console.log("and is: "+rotation);
		}
		
		// console.log("should rotate "+rotation);
		totRot[0] = Math.cos(rotation);
		totRot[2] = -Math.sin(rotation);
		totRot[8]= Math.sin(rotation);;
		totRot[10] = Math.cos(rotation);
		
		gl.activeTexture(gl.TEXTURE0);
        if (board.texture.isFinished) {
                gl.bindTexture(gl.TEXTURE_2D, board.texture);
            } else{
                gl.bindTexture(gl.TEXTURE_2D, oneByOneTexture);
            }
		gl.uniform1i(board.shader.samplerUniform, 0);
				
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				
		gl.bindBuffer(gl.ARRAY_BUFFER,  board.meshData.vertexBuffer);
        gl.vertexAttribPointer(board.shader.vertexPositionAttribute,  board.meshData.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
		gl.uniformMatrix4fv(board.shader.camMatrix, false, camMat);
		gl.uniformMatrix4fv(board.shader.frustum, false, projection);

        if(! board.meshData.textures.length){
            gl.disableVertexAttribArray(board.shader.textureCoordAttribute);
        } else {
            gl.enableVertexAttribArray(board.shader.textureCoordAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER, board.meshData.textureBuffer);
            gl.vertexAttribPointer(board.shader.textureCoordAttribute,  board.meshData.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  board.meshData.indexBuffer);
        
		gl.uniformMatrix4fv(board.shader.mvMatrixUniform, false, board.positionMatrix);
   
		gl.uniformMatrix4fv(board.shader.RMatrixUniform, false, totRot);
        gl.drawElements(gl.TRIANGLES,  board.meshData.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

	}
	
    function drawModel(model) {
        gl.useProgram(model.shader);
        gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.vertexBuffer);
        gl.vertexAttribPointer(model.shader.vertexPositionAttribute,  model.meshData.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
        if(model.shader.showSpecularHighlightsUniform != null)
            gl.uniform1i(model.shader.showSpecularHighlightsUniform, specularHighlights);
        if(model.shader.useLightingUniform != null)
            gl.uniform1i(model.shader.useLightingUniform, ifLighting);
        if(model.shader.ambientColorUniform != null)
            gl.uniform3f(model.shader.ambientColorUniform, lightColor.x, lightColor.y, lightColor.z);
        if(model.shader.pointLightingLocationUniform != null)
            gl.uniform3f(model.shader.pointLightingLocationUniform, lightLocation.x, lightLocation.y, lightLocation.z);
        if(model.shader.pointLightingSpecularColorUniform != null)
            gl.uniform3f(model.shader.pointLightingSpecularColorUniform, speccColor.x, speccColor.y, speccColor.z);
        if(model.shader.pointLightingDiffuseColorUniform != null)
            gl.uniform3f(model.shader.pointLightingDiffuseColorUniform, diffuseColor.x, diffuseColor.y, diffuseColor.z);
        if(model.shader.materialShininessUniform != null)
            gl.uniform1f(model.shader.materialShininessUniform, shininess);
        if (model.shader.lightSources){
            var lghtSources = [];
            for (var i = 0; i < model.lightSources.length; i++) {
                lghtSources.push(model.lightSources[i].positionMatrix[12]);
                lghtSources.push(model.lightSources[i].positionMatrix[13]);
                lghtSources.push(model.lightSources[i].positionMatrix[14]);
            }
            gl.uniform1f(model.shader.amountOfLightSources, i);
            gl.uniform3fv(model.shader.lightSources, lghtSources);
        }

        var camMat = keyboardControls.getCamMatrix();
        gl.uniformMatrix4fv(model.shader.camMatrix, false, camMat);
        gl.uniformMatrix4fv(model.shader.projection, false, projection);

        if(model.hasBumpMap){
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, model.bumpMap);
            gl.uniform1i(model.shader.bumpMap, 1);
        }
        if(model.texture != null){
            gl.activeTexture(gl.TEXTURE0);
            if (model.texture.isFinished) {
                    gl.bindTexture(gl.TEXTURE_2D, model.texture);
                    // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                } else{
                    gl.bindTexture(gl.TEXTURE_2D, oneByOneTexture);
                }
            gl.uniform1i(model.shader.samplerUniform, 0);
        }

        if(! model.meshData.textures.length){
            gl.disableVertexAttribArray(model.shader.textureCoordAttribute);
        } else {
            gl.enableVertexAttribArray(model.shader.textureCoordAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER, model.meshData.textureBuffer);
            gl.vertexAttribPointer(model.shader.textureCoordAttribute,  model.meshData.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }

        if(model.shader.vertexNormalAttribute != null){
            gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.normalBuffer);
            gl.vertexAttribPointer(model.shader.vertexNormalAttribute,  model.meshData.normalBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  model.meshData.indexBuffer);
        setMatrixUniforms(model);
        gl.drawElements(gl.TRIANGLES,  model.meshData.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }

    function drawTerrain(){
        gl.useProgram(terrain.shader);
        var camMat = keyboardControls.getCamMatrix();
        gl.uniformMatrix4fv(terrain.shader.camMatrix, false, camMat);
        gl.uniformMatrix4fv(terrain.shader.projection, false, projection);
        gl.uniformMatrix4fv(terrain.shader.lightMatrix, false, lightMat);
        gl.uniformMatrix4fv(terrain.shader.lightProjection, false, lightProjection);
        gl.uniform3f(terrain.shader.pointLightingLocationUniform, lightLocation.x, lightLocation.y, lightLocation.z);

        gl.activeTexture(gl.TEXTURE0);
        if (noiseBumpMap.isFinished) {
                gl.bindTexture(gl.TEXTURE_2D, noiseBumpMap);
            } else{
                gl.bindTexture(gl.TEXTURE_2D, oneByOneTexture);
        }
        gl.uniform1i(terrain.shader.samplerUniform, 0);

        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, depthTexture);
        gl.uniform1i(terrain.shader.shadowTex, 1);

        gl.bindBuffer(gl.ARRAY_BUFFER,  terrain.vertexBuffer);
        gl.vertexAttribPointer(terrain.shader.vertexPositionAttribute,  terrain.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER,  terrain.colorBuffer);
        gl.vertexAttribPointer(terrain.shader.vertexColorAttribute,  terrain.colorBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER,  terrain.normalBuffer);
        gl.vertexAttribPointer(terrain.shader.vertexNormalAttribute,  terrain.normalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  terrain.indexBuffer);

        // gl.uniformMatrix4fv(terrainShader.mvMatrixUniform, false, terrain.positionMatrix);
        setMatrixUniforms(terrain);

        gl.drawElements(gl.TRIANGLES,  terrain.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }
	function drawTerrain2(){
        gl.useProgram(outerTerrain.shader);
	/**	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
		**/
		
        var camMat = keyboardControls.getCamMatrix();
        gl.uniformMatrix4fv(outerTerrain.shader.camMatrix, false, camMat);
        gl.uniformMatrix4fv(outerTerrain.shader.frustum, false, projection);

        gl.activeTexture(gl.TEXTURE0);
        if (outerTerrain.texture.isFinished) {
                gl.bindTexture(gl.TEXTURE_2D, outerTerrain.texture);
            } else{
                gl.bindTexture(gl.TEXTURE_2D, oneByOneTexture);
        }
        gl.uniform1i(outerTerrain.shader.samplerUniform, 0);

		if(! outerTerrain.meshData.textures.length){
            gl.disableVertexAttribArray(outerTerrain.shader.textureCoordAttribute);
       } else {
            gl.enableVertexAttribArray(outerTerrain.shader.textureCoordAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER,  outerTerrain.meshData.textureBuffer);
            gl.vertexAttribPointer(outerTerrain.shader.textureCoordAttribute,  outerTerrain.meshData.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }
		
        gl.bindBuffer(gl.ARRAY_BUFFER,  outerTerrain.meshData.vertexBuffer);
        gl.vertexAttribPointer(outerTerrain.shader.vertexPositionAttribute,  outerTerrain.meshData.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

       // gl.bindBuffer(gl.ARRAY_BUFFER,  outerTerrain.meshData.colorBuffer);
        //gl.vertexAttribPointer(outerTerrain.shader.vertexColorAttribute,  outerTerrain.meshData.colorBuffer.itemSize, gl.FLOAT, false, 0, 0);

       // gl.bindBuffer(gl.ARRAY_BUFFER,  outerTerrain.meshData.normalBuffer);
        //gl.vertexAttribPointer(outerTerrain.shader.vertexNormalAttribute,  outerTerrain.meshData.normalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  outerTerrain.meshData.indexBuffer);

         gl.uniformMatrix4fv(outerTerrain.shader.mvMatrixUniform, false, outerTerrain.positionMatrix);
        setMatrixUniforms(outerTerrain);

        gl.drawElements(gl.TRIANGLES,  outerTerrain.meshData.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }

    function drawSkyBoxes(){
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        for (var i = 0; i < skyBoxes.length; i++) {
            if(skyBoxes[i] != null && skyBoxes[i].texture != null){
                drawSky(skyBoxes[i]);
            }
        }
        gl.disable(gl.BLEND);
        gl.enable(gl.DEPTH_TEST);
    }

    function drawSky(model){
        gl.useProgram(model.shader);

        var camMat = keyboardControls.getCamMatrix();
        var time = keyboardControls.getElapsedTime();
        var temp = mat4.clone(camMat);
        temp[12]=0;
        temp[13]=-0.5;
        temp[14]=0;
        gl.uniformMatrix4fv(model.shader.camMatrix, false, temp);
        gl.uniformMatrix4fv(model.shader.projection, false, projection);

        if (model.rotVec != null) {
            mat4.rotate(model.positionMatrix, model.positionMatrix, degToRad(model.rotSpeed * time), [model.rotVec.x, model.rotVec.y, model.rotVec.z]);
            gl.uniformMatrix4fv(model.shader.mvMatrixUniform, false, model.positionMatrix);
        } else{
            mat4.identity(temp);
            gl.uniformMatrix4fv(model.shader.mvMatrixUniform, false, temp);
        }

        gl.activeTexture(gl.TEXTURE0);
        if (model.texture.isFinished) {
                gl.bindTexture(gl.TEXTURE_2D, model.texture);
            } else{
                gl.bindTexture(gl.TEXTURE_2D, oneByOneTexture);
            }
        gl.uniform1i(model.shader.samplerUniform, 0);
        
        gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.vertexBuffer);
        gl.vertexAttribPointer(model.shader.vertexPositionAttribute,  model.meshData.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        if(! model.meshData.textures.length){
            gl.disableVertexAttribArray(model.shader.textureCoordAttribute);
       } else {
            gl.enableVertexAttribArray(model.shader.textureCoordAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.textureBuffer);
            gl.vertexAttribPointer(model.shader.textureCoordAttribute,  model.meshData.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  model.meshData.indexBuffer);

        gl.drawElements(gl.TRIANGLES,  model.meshData.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }

    var once = false;

    function tick() {
        requestAnimFrame(tick);
        keyboardControls.handleKeys(ourObjects);
        drawScene();
        keyboardControls.animate();
    }

    function loadObjects(){
        OBJ.downloadMeshes({
			'skyBox': 'objects/skybox.obj',
            'lamp': 'objects/simple_sphere.obj',
            'cubePlus': 'objects/cubePlus.obj',
            'cubePlusMedium': 'objects/cubePlusMedium.obj',
            'rectanglePlusMedium': 'objects/rectanglePlusMedium.obj',
            'rectanglePlusMedium2': 'objects/rectanglePlusMedium2.obj',
            'teapot': 'objects/teapot.obj',
            'eHouse': 'objects/emilHouse3.obj',
			'billBoard': 'objects/billboard.obj',
			'outerTerrain': 'objects/outerTerrain.obj'
        }, webGLAddObj);
    }

    function webGLStart() {
        var canvas = document.getElementById("lesson14-canvas");
        initGL(canvas);
        initTextures();
        initShaders();
        createFBOAndTexture();
        mat4.perspective(projection, 45, gl.viewportWidth / gl.viewportHeight, 0.1, 200.0);
        lightMat = mat4.create();
        loadObjects();
        keyboardControls = new keyboardControls();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;

        tick();
    }

    function printOnce(object){
        if(object != null && !once){
            console.log(object);
        } else if (!once){
            console.log("This object was null")
        }
            once = true;
    }

    function getHTMLVars(){
        specularHighlights = document.getElementById("specular").checked;

        ifLighting = document.getElementById("lighting").checked;

        shininess = parseFloat(document.getElementById("shininess").value);

        if (ifLighting) {
            lightColor = {x:parseFloat(document.getElementById("ambientR").value), y:parseFloat(document.getElementById("ambientG").value), z:parseFloat(document.getElementById("ambientB").value)};


           lightLocation = {x:parseFloat(document.getElementById("lightPositionX").value), y:parseFloat(document.getElementById("lightPositionY").value), z:parseFloat(document.getElementById("lightPositionZ").value)};

            speccColor = {x:parseFloat(document.getElementById("specularR").value), y:parseFloat(document.getElementById("specularG").value), z:parseFloat(document.getElementById("specularB").value)};

            diffuseColor = {x:parseFloat(document.getElementById("diffuseR").value), y:parseFloat(document.getElementById("diffuseG").value), z:parseFloat(document.getElementById("diffuseB").value)};
        }
    }

    function lookAt(){
    var lightLoc = vec3.fromValues(lightLocation.x, lightLocation.y, lightLocation.z);
    var focal = vec3.fromValues(0, -13.3361, 9.5395);
    var up = vec3.fromValues(0, 1, 0);

    var n = vec3.create(), u = vec3.create(), v = vec3.create();

    vec3.subtract(n, lightLoc, focal);
    vec3.normalize(n, n);
    vec3.cross(u, up, n)
    vec3.normalize(u, u);
    vec3.cross(v, n, u);

    var rot = mat4.create();
    mat4.identity(rot);
    var trans = mat4.clone(rot);
    rot[0] = u[0];
    rot[1] = u[1];
    rot[2] = u[2];

    rot[3] = v[0];
    rot[4] = v[1];
    rot[5] = v[2];

    rot[6] = n[0];
    rot[7] = n[1];
    rot[8] = n[2];

    mat4.translate(trans, trans, [-lightLocation.x, -lightLocation.y, -lightLocation.z]);
    mat4.multiply(lightMat, rot, trans);
    mat4.ortho(lightProjection, -0.5, 0.5, -0.5, 0.5, 1.0, 200);
    // lightMat is now the lookAt matrix
    }

</script>

</head>

<body onload="webGLStart();">
    <canvas id="lesson14-canvas" style="border: none;" width="1000" height="500"></canvas>

    <br/>

    <input type="checkbox" id="specular" checked /> Show specular highlight<br/>
    <input type="checkbox" id="lighting" checked /> Use lighting<br/>

    <h2>Material:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Shininess:</b>
            <td><input type="text" id="shininess" value="32.0" />
        </tr>
    </table>

    <h2>Point light:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Location:</b>
            <td>X: <input type="text" id="lightPositionX" value="-70.0" />
            <td>Y: <input type="text" id="lightPositionY" value="16.0" />
            <td>Z: <input type="text" id="lightPositionZ" value="-30.0" />
        </tr>
        <tr>
            <td><b>Specular colour:</b>
            <td>R: <input type="text" id="specularR" value="0.8" />
            <td>G: <input type="text" id="specularG" value="0.8" />
            <td>B: <input type="text" id="specularB" value="0.8" />
        </tr>
        <tr>
            <td><b>Diffuse colour:</b>
            <td>R: <input type="text" id="diffuseR" value="0.8" />
            <td>G: <input type="text" id="diffuseG" value="0.8" />
            <td>B: <input type="text" id="diffuseB" value="0.8" />
        </tr>
    </table>

    <h2>Ambient light:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Colour:</b>
            <td>R: <input type="text" id="ambientR" value="0.1" />
            <td>G: <input type="text" id="ambientG" value="0.1" />
            <td>B: <input type="text" id="ambientB" value="0.1" />
        </tr>
    </table>
    <br/>
</body>

</html>
