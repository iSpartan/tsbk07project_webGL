<html>

<head>
<title>Learning WebGL &mdash; lesson 1</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

  <link rel="stylesheet" href="css/app.css"/>

<script type="text/javascript" src="utils/jquery-1.11.2.min.js"></script>
<script type="text/javascript" src="utils/gl-matrix.js"></script>
<script type="text/javascript" src="utils/loadShaderUtil.js"></script>
<script type="text/javascript" src="utils/webgl-obj-loader.js"></script>
<script type="text/javascript" src="utils/webgl-utils.js"></script>
<script type="text/javascript" src="utils/terrain.js"></script>
<script type="text/javascript" src="utils/keyboardControls.js"></script>

<script type="text/javascript">

    var gl;
    var keyboardControls;
    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.getExtension('OES_standard_derivatives');
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    function handleKeyDown(event) {
        keyboardControls.handleKeyDown(event);
    }

    function handleKeyUp(event) {
        keyboardControls.handleKeyUp(event);
    }
	
    var teapotShader;
	var skyBoxShaders;
    var terrainShader;
	var billBoardShaders;
    var crateShader;


    function setTeapotShaderProgramVars() {
        gl.useProgram(teapotShader);

        teapotShader.vertexPositionAttribute = gl.getAttribLocation(teapotShader, "aVertexPosition");
        gl.enableVertexAttribArray(teapotShader.vertexPositionAttribute);

        teapotShader.vertexNormalAttribute = gl.getAttribLocation(teapotShader, "aVertexNormal");
        gl.enableVertexAttribArray(teapotShader.vertexNormalAttribute);

        teapotShader.textureCoordAttribute = gl.getAttribLocation(teapotShader, "aTextureCoord");
        gl.enableVertexAttribArray(teapotShader.textureCoordAttribute);

        teapotShader.frustum = gl.getUniformLocation(teapotShader, "frustum");
        teapotShader.camMatrix = gl.getUniformLocation(teapotShader, "camMatrix");
        teapotShader.mvMatrixUniform = gl.getUniformLocation(teapotShader, "uMVMatrix");
        teapotShader.nMatrixUniform = gl.getUniformLocation(teapotShader, "uNMatrix");
        teapotShader.samplerUniform = gl.getUniformLocation(teapotShader, "uSampler");
        teapotShader.materialShininessUniform = gl.getUniformLocation(teapotShader, "uMaterialShininess");
        teapotShader.showSpecularHighlightsUniform = gl.getUniformLocation(teapotShader, "uShowSpecularHighlights");
        teapotShader.useTexturesUniform = gl.getUniformLocation(teapotShader, "uUseTextures");
        teapotShader.useLightingUniform = gl.getUniformLocation(teapotShader, "uUseLighting");
        teapotShader.ambientColorUniform = gl.getUniformLocation(teapotShader, "uAmbientColor");
        teapotShader.pointLightingLocationUniform = gl.getUniformLocation(teapotShader, "uPointLightingLocation");
        teapotShader.pointLightingSpecularColorUniform = gl.getUniformLocation(teapotShader, "uPointLightingSpecularColor");
        teapotShader.pointLightingDiffuseColorUniform = gl.getUniformLocation(teapotShader, "uPointLightingDiffuseColor");
    }

    function setskyBoxShaderProgramVars(){
        gl.useProgram(skyBoxShaders);

        skyBoxShaders.vertexPositionAttribute = gl.getAttribLocation(skyBoxShaders, "aVertexPosition");
        gl.enableVertexAttribArray(skyBoxShaders.vertexPositionAttribute);

        skyBoxShaders.textureCoordAttribute = gl.getAttribLocation(skyBoxShaders, "aTexCoord");
        gl.enableVertexAttribArray(skyBoxShaders.textureCoordAttribute);

        skyBoxShaders.camMatrix = gl.getUniformLocation(skyBoxShaders, "camMatrix");
        skyBoxShaders.frustum = gl.getUniformLocation(skyBoxShaders, "frustum");
        skyBoxShaders.samplerUniform = gl.getUniformLocation(skyBoxShaders, "uTexSky");
        skyBoxShaders.mvMatrixUniform = gl.getUniformLocation(skyBoxShaders, "uMVMatrix");
    }

    function setTerrainShaderProgramVars() {
        gl.useProgram(terrainShader);

        terrainShader.vertexPositionAttribute = gl.getAttribLocation(terrainShader, "aVertexPosition");
        gl.enableVertexAttribArray(terrainShader.vertexPositionAttribute);

        terrainShader.vertexNormalAttribute = gl.getAttribLocation(terrainShader, "aVertexNormal");
        gl.enableVertexAttribArray(terrainShader.vertexNormalAttribute);

        terrainShader.vertexColorAttribute = gl.getAttribLocation(terrainShader, "aColorAttrib");
        gl.enableVertexAttribArray(terrainShader.vertexColorAttribute);

        // terrainShader.textureCoordAttribute = gl.getAttribLocation(terrainShader, "aTextureCoord");
        // gl.enableVertexAttribArray(terrainShader.textureCoordAttribute);

        terrainShader.mvMatrixUniform = gl.getUniformLocation(terrainShader, "uMVMatrix");
        terrainShader.frustum = gl.getUniformLocation(terrainShader, "frustum");
        terrainShader.camMatrix = gl.getUniformLocation(terrainShader, "camMatrix");
        terrainShader.samplerUniform = gl.getUniformLocation(terrainShader, "uTexBump");
        terrainShader.nMatrixUniform = gl.getUniformLocation(terrainShader, "uNMatrix");
    }

    function setCrateShaderProgramVars() {
        gl.useProgram(crateShader);

        crateShader.vertexPositionAttribute = gl.getAttribLocation(crateShader, "aVertexPosition");
        gl.enableVertexAttribArray(crateShader.vertexPositionAttribute);

        crateShader.vertexNormalAttribute = gl.getAttribLocation(crateShader, "aVertexNormal");
        gl.enableVertexAttribArray(crateShader.vertexNormalAttribute);

        crateShader.textureCoordAttribute = gl.getAttribLocation(crateShader, "aTextureCoord");
        gl.enableVertexAttribArray(crateShader.textureCoordAttribute);

        crateShader.frustum = gl.getUniformLocation(crateShader, "frustum");
        crateShader.camMatrix = gl.getUniformLocation(crateShader, "camMatrix");
        crateShader.mvMatrixUniform = gl.getUniformLocation(crateShader, "uMVMatrix");
        crateShader.nMatrixUniform = gl.getUniformLocation(crateShader, "uNMatrix");
        crateShader.samplerUniform = gl.getUniformLocation(crateShader, "uSampler");
        crateShader.materialShininessUniform = gl.getUniformLocation(crateShader, "uMaterialShininess");
        crateShader.showSpecularHighlightsUniform = gl.getUniformLocation(crateShader, "uShowSpecularHighlights");
        crateShader.useTexturesUniform = gl.getUniformLocation(crateShader, "uUseTextures");
        crateShader.useLightingUniform = gl.getUniformLocation(crateShader, "uUseLighting");
        crateShader.ambientColorUniform = gl.getUniformLocation(crateShader, "uAmbientColor");
        crateShader.pointLightingLocationUniform = gl.getUniformLocation(crateShader, "uPointLightingLocation");
        crateShader.pointLightingSpecularColorUniform = gl.getUniformLocation(crateShader, "uPointLightingSpecularColor");
        crateShader.pointLightingDiffuseColorUniform = gl.getUniformLocation(crateShader, "uPointLightingDiffuseColor");
    }
	function setBillBoardShaderProgramVars() {
        gl.useProgram(billBoardShaders);

        billBoardShaders.vertexPositionAttribute = gl.getAttribLocation(billBoardShaders, "aVertexPosition");
        gl.enableVertexAttribArray(billBoardShaders.vertexPositionAttribute);

        //billBoardShaders.vertexNormalAttribute = gl.getAttribLocation(billBoardShaders, "aVertexNormal");
        //gl.enableVertexAttribArray(billBoardShaders.vertexNormalAttribute);

        billBoardShaders.textureCoordAttribute = gl.getAttribLocation(billBoardShaders, "aTextureCoord");
        gl.enableVertexAttribArray(billBoardShaders.textureCoordAttribute);

	   billBoardShaders.frustum = gl.getUniformLocation(billBoardShaders, "frustum");
        billBoardShaders.camMatrix = gl.getUniformLocation(billBoardShaders, "camMatrix");
        billBoardShaders.mvMatrixUniform = gl.getUniformLocation(billBoardShaders, "uMVMatrix");
        billBoardShaders.samplerUniform = gl.getUniformLocation(billBoardShaders, "uTexBill");
		billBoardShaders.RMatrixUniform = gl.getUniformLocation(billBoardShaders, "uRMatrix");

    }

    function initShaders() {

        teapotShader = utils.addShaderProg(gl, 'teapot.vertex', 'teapot.frag');
        terrainShader = utils.addShaderProg(gl, 'terrain.vertex', 'terrain.frag');
		skyBoxShaders = utils.addShaderProg(gl, 'skyBox.vertex', 'skyBox.frag');
		billBoardShaders = utils.addShaderProg(gl, 'billBoard.vertex', 'billboard.frag');
        crateShader = utils.addShaderProg(gl, "crateShader.vertex", "crateShader.frag");
        setTeapotShaderProgramVars();
        setTerrainShaderProgramVars();
        setskyBoxShaderProgramVars();
		setBillBoardShaderProgramVars();
        setCrateShaderProgramVars();

    }

    function handleLoadedTexture(texture) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.bindTexture(gl.TEXTURE_2D, null);
        texture.isFinished = true;
    }

    function handleLoadedHeightMap(texture) {
        gl.useProgram(terrainShader);
        terrain = new TerrainBlock(terrainHeightMap, 256, 256, 256, 256);
        terrain.isFinished = false;

        var pos = mat4.create();
        mat4.identity(pos);
        mat4.translate(pos, pos, [ -80, -15, -80]);

        terrain.positionMatrix = pos;
        terrain.buildVertices();
        terrain.buildIndices();
        terrain.buildBuffers(gl);
		
    }

    var galvanizedTexture;
    var earthTexture;
	var skyTexture;
    var cloudTexture1;
    var cloudTexture2;
    var cloudTexture3;
	var terrainHeightMap;
    var oneByOneTexture;
	var billBoardTexture;
    var noiseBumpMap;
    var crateTexture;

    function initTextures() {

        oneByOneTexture = setUpTextures(oneByOneTexture, "1x1.jpg");
        galvanizedTexture = setUpTextures(galvanizedTexture, "arroway.de_metal+structure+06_d100_flat.jpg");
        noiseBumpMap = setUpTextures(noiseBumpMap, "noise.jpg");
        earthTexture = setUpTextures(earthTexture, "earth.jpg");
        skyTexture = setUpTextures(skyTexture, "SkyBox512.jpg");
        cloudTexture1 = setUpTextures(cloudTexture1, "cloudTex1.png");
        cloudTexture2 = setUpTextures(cloudTexture2, "cloudTex2.png");
        cloudTexture3 = setUpTextures(cloudTexture3, "cloudTex3.png");
        crateTexture = setUpTextures(crateTexture, "crate.gif");
		billBoardTexture = setUpTextures(billBoardTexture, "noise.jpg");
        terrainHeightMap = new Image();
        terrainHeightMap.onload = function () {
            handleLoadedHeightMap(terrainHeightMap)
        }
        terrainHeightMap.src = "textures/fft-terrain.jpg";
		
        // terrainHeightMap.src = "textures/44-terrain.jpg";
		
		
    }

    function setUpTextures(textureVarName, picture){
        textureVarName = gl.createTexture();
        textureVarName.isFinished = false;
        textureVarName.image = new Image();
        textureVarName.image.onload = function () {
            handleLoadedTexture(textureVarName)
        }
        textureVarName.image.src = "textures/"+picture;
        return textureVarName;
    }

    var frustum = mat4.create();
	
    function setMatrixUniforms(shader, model) {
        if (model.movable) {
            var temp = keyboardControls.getObjPos();
            // console.log(temp)
            mat4.multiply(temp, model.positionMatrix, temp);
            // console.log(temp)
            gl.uniformMatrix4fv(shader.mvMatrixUniform, false, temp);
        }else{
            gl.uniformMatrix4fv(shader.mvMatrixUniform, false, model.positionMatrix);
        }

        var normalMatrix = mat3.create();
        mat3.fromMat4(normalMatrix, model.positionMatrix);
        mat3.invert(normalMatrix, normalMatrix);
        mat3.transpose(normalMatrix, normalMatrix);
        gl.uniformMatrix3fv(shader.nMatrixUniform, false, normalMatrix);
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    var ourMeshes = {};
    var ourObjects = [];
    var terrain = {};
    var skyBoxes = [];

    function webGLAddObj(meshes){
        ourMeshes = meshes;
        OBJ.initMeshBuffers(gl, ourMeshes.teapot);
		OBJ.initMeshBuffers(gl, ourMeshes.skyBox);
        OBJ.initMeshBuffers(gl, ourMeshes.cubePlusMedium);
        OBJ.initMeshBuffers(gl, ourMeshes.rectanglePlusMedium);
        OBJ.initMeshBuffers(gl, ourMeshes.eHouse);
		OBJ.initMeshBuffers(gl, ourMeshes.billBoard);
		OBJ.initMeshBuffers(gl, ourMeshes.outerTerrain);
        createBillboard();
		createObjects();
		
    }

	var outerTerrain;
    function createObjects(){
        var teapot1, teapot2, eHouse, skyBox, cloudBox1, cloudBox2, cloudBox3, crate, crate2, crate3;

        teapot1 = {name:"teapot1"};
        teapot1.meshData = ourMeshes.teapot;
        teapot1.texture = galvanizedTexture;
		teapot1.radius = 10;
        teapot1.movable = false;
        teapot1.shader = teapotShader;

        teapot2 = {name:"teapot2"};
        teapot2.meshData = ourMeshes.teapot;
        teapot2.texture = earthTexture;
		teapot2.radius = 10;
        teapot2.movable = false;
        teapot2.shader = teapotShader;

        cloudBox1 = {name:"cloudBox1"};
        cloudBox1.meshData = ourMeshes.skyBox;
        cloudBox1.texture = cloudTexture1;
        cloudBox1.movable = false;
        cloudBox1.shader = skyBoxShaders;

        cloudBox2 = {name:"cloudBox2"};
        cloudBox2.meshData = ourMeshes.skyBox;
        cloudBox2.texture = cloudTexture2;
        cloudBox2.movable = false;
        cloudBox2.shader = skyBoxShaders;

        cloudBox3 = {name:"cloudBox3"};
        cloudBox3.meshData = ourMeshes.skyBox;
        cloudBox3.texture = cloudTexture3;
        cloudBox3.movable = false;
        cloudBox3.shader = skyBoxShaders;

        skyBox = {name:"skyBox"};
        skyBox.meshData = ourMeshes.skyBox;
        skyBox.texture = skyTexture;
        skyBox.movable = false;
        skyBox.shader = skyBoxShaders;

        eHouse = {name: "eHouse"};
        eHouse.meshData = ourMeshes.eHouse;
        eHouse.texture = galvanizedTexture;
        eHouse.radius = 1;

		outerTerrain = {name:"outerTerrain"};
		outerTerrain.meshData = ourMeshes.outerTerrain;
		outerTerrain.radius = 1;

        eHouse.movable = false;
        eHouse.shader = teapotShader;

        crate = {name: "crate"};
        crate.meshData = ourMeshes.cubePlusMedium;
        crate.texture = crateTexture;
        crate.radius = 1;
        crate.movable = false;
        crate.shader = crateShader;

        crate2 = {name: "crate2"};
        crate2.meshData = ourMeshes.rectanglePlusMedium;
        crate2.texture = crateTexture;
        crate2.radius = 1;
        crate2.movable = false;
        crate2.shader = crateShader;


        crate3 = {name: "crate3"};
        crate3.meshData = ourMeshes.rectanglePlusMedium;
        crate3.texture = crateTexture;
        crate3.radius = 1;
        crate3.movable = false;
        crate3.shader = crateShader;


        var posMat = mat4.create();
        mat4.identity(posMat);

        skyBox.positionMatrix = mat4.clone(posMat);
        cloudBox1.positionMatrix = mat4.clone(posMat);
        cloudBox2.positionMatrix = mat4.clone(posMat);
        cloudBox3.positionMatrix = mat4.clone(posMat);
        cloudBox1.rotVec = {x:1, y:1, z:1};
        cloudBox1.rotSpeed = 0.0002;
        cloudBox2.rotVec = {x:1, y:-1, z:-1};
        cloudBox2.rotSpeed = 0.0004;
        cloudBox3.rotVec = {x:-1, y:-1, z:1};
        cloudBox3.rotSpeed = 0.0003;

        skyBoxes.push(skyBox);
        skyBoxes.push(cloudBox3);
        skyBoxes.push(cloudBox2);
        skyBoxes.push(cloudBox1);

        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [-10, 0, -40]);
        mat4.rotate(posMat, posMat, degToRad(23.4), [1, 0, -1]);
        mat4.rotate(posMat, posMat, degToRad(teapotAngle), [0, 1, 0]);
        teapot1.positionMatrix = mat4.clone(posMat);
        ourObjects.push(teapot1);

        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [10, 0, -40]);
        mat4.rotate(posMat, posMat, degToRad(-23.4), [1, 0, -1]);
        mat4.rotate(posMat, posMat, degToRad(-teapotAngle), [0, 1, 0]);
        teapot2.positionMatrix = mat4.clone(posMat);
        ourObjects.push(teapot2);
	
		mat4.identity(posMat);
        mat4.translate(posMat, posMat, [-500, -1, 500]);
        outerTerrain.positionMatrix = mat4.clone(posMat);
    
        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [-10, -15, 30]);
        mat4.rotate(posMat, posMat, degToRad(0), [0, 1, 0]);
        eHouse.positionMatrix = mat4.clone(posMat);
        ourObjects.push(eHouse);

        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [-14.9331, -13.3361, 19.3915]);
        mat4.rotate(posMat, posMat, degToRad(0), [0, 1, 0]);
        crate.positionMatrix = mat4.clone(posMat);
        ourObjects.push(crate);

        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [16.4274, -13.3361, 21.4712]);
        mat4.rotate(posMat, posMat, degToRad(90), [0, 1, 0]);
        crate2.positionMatrix = mat4.clone(posMat);
        ourObjects.push(crate2);

        mat4.identity(posMat);
        mat4.translate(posMat, posMat, [-5.2840, -11.3361, 9.5395]);
        mat4.rotate(posMat, posMat, degToRad(180), [1, 1, 0]);
        mat4.rotate(posMat, posMat, 1.06, [1, 0, 0]);
        crate3.positionMatrix = mat4.clone(posMat);
        ourObjects.push(crate3);
		//createBillboard();
    }
	
	var billBoard;
	function createBillboard(){
		var billPos = mat4.create();
		mat4.identity(billPos);
		mat4.translate(billPos, billPos, [-0, 0, -0]);
		billBoard = {name:"billBoard"};
        billBoard.meshData = ourMeshes.billBoard;
		billBoard.positionMatrix = billPos;
		billBoard.texture = billBoardTexture;
	}

    var teapotAngle = 180;

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        drawSkyBoxes();
		drawObjects();
		drawBillboard(billBoard);
        
        if (terrain != null && terrain.isFinished) {
            drawTerrain();
        }

        if(!once && terrain != null && terrain.isFinished && skyBoxes[0] != null){
        // console.log(terrain);
        // console.log(skyBoxes[0]);
		console.log(billBoard)
        once = true;
        }
    }

    function drawObjects(){
        gl.useProgram(teapotShader);

        var specularHighlights = document.getElementById("specular").checked;
        gl.uniform1i(teapotShader.showSpecularHighlightsUniform, specularHighlights);

        var lighting = document.getElementById("lighting").checked;
        gl.uniform1i(teapotShader.useLightingUniform, lighting);
        if (lighting) {
           gl.uniform3f(
               teapotShader.ambientColorUniform,
               parseFloat(document.getElementById("ambientR").value),
               parseFloat(document.getElementById("ambientG").value),
               parseFloat(document.getElementById("ambientB").value)
           );

           gl.uniform3f(
               teapotShader.pointLightingLocationUniform,
               parseFloat(document.getElementById("lightPositionX").value),
               parseFloat(document.getElementById("lightPositionY").value),
               parseFloat(document.getElementById("lightPositionZ").value)
           );

           gl.uniform3f(
               teapotShader.pointLightingSpecularColorUniform,
               parseFloat(document.getElementById("specularR").value),
               parseFloat(document.getElementById("specularG").value),
               parseFloat(document.getElementById("specularB").value)
           );

           gl.uniform3f(
               teapotShader.pointLightingDiffuseColorUniform,
               parseFloat(document.getElementById("diffuseR").value),
               parseFloat(document.getElementById("diffuseG").value),
               parseFloat(document.getElementById("diffuseB").value)
           );
        }

        var texture = document.getElementById("texture").value;
        gl.uniform1i(teapotShader.useTexturesUniform, texture != "none");

        gl.uniform1f(teapotShader.materialShininessUniform, parseFloat(document.getElementById("shininess").value));
		var camMat = keyboardControls.getCamMatrix();	
		var temp = mat4.create();
		mat4.identity(temp);
		gl.uniformMatrix4fv(teapotShader.camMatrix, false, camMat);
		gl.uniformMatrix4fv(teapotShader.frustum, false, frustum);
		
        for (var i = 0; i < ourObjects.length; i++) {
           drawModel(ourObjects[i]);
        }
    }

    function drawSkyBoxes(){
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        for (var i = 0; i < skyBoxes.length; i++) {
            if(skyBoxes[i] != null && skyBoxes[i].texture != null){
                drawSky(skyBoxes[i]);
            }
        }
        gl.disable(gl.BLEND);
        gl.enable(gl.DEPTH_TEST);
    }
	function getModelDirection(posMatrix, camMatrix){
        var pos = mat4.create();
		
        mat4.multiply(pos, camMatrix, posMatrix);
        var posVec = vec3.create();
		var length = Math.sqrt(pos[12]*pos[12]+pos[13]*pos[13]+pos[14]*pos[14]);
		
		
        posVec[0] = pos[12]/length;
        posVec[1] = pos[13]/length;
        posVec[2] = pos[14]/length;
        return posVec;
    }

	function drawBillboard(board){
		gl.useProgram(billBoardShaders);
		var cosa, sina, rotMat;
        var camMat = keyboardControls.getCamMatrix();
		var directionFromModel = getModelDirection(board.positionMatrix, camMat);
		directionFromModel[1] = 0; //zero the y
		sina = directionFromModel[0];
		cosa = directionFromModel[2];
		rotMat = mat4.create();
		mat4.identity(rotMat);
		rotMat[0] = cosa;
		rotMat[2] = sina;
		rotMat[6] = -sina;
		rotMat[8] = cosa;
		
		gl.activeTexture(gl.TEXTURE0);
        if (skyTexture.isFinished) {
                gl.bindTexture(gl.TEXTURE_2D, skyTexture);
            } else{
                gl.bindTexture(gl.TEXTURE_2D, oneByOneTexture);
            }
		gl.uniform1i(billBoardShaders.samplerUniform, 0);
				
		gl.bindBuffer(gl.ARRAY_BUFFER,  board.meshData.vertexBuffer);
        gl.vertexAttribPointer(billBoardShaders.vertexPositionAttribute,  board.meshData.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
		gl.uniformMatrix4fv(billBoardShaders.camMatrix, false, camMat);
		gl.uniformMatrix4fv(billBoardShaders.frustum, false, frustum);

        if(! board.meshData.textures.length){
            gl.disableVertexAttribArray(billBoardShaders.textureCoordAttribute);
        } else {
            gl.enableVertexAttribArray(billBoardShaders.textureCoordAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER, board.meshData.textureBuffer);
            gl.vertexAttribPointer(billBoardShaders.textureCoordAttribute,  board.meshData.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }
		

    //    gl.bindBuffer(gl.ARRAY_BUFFER,  board.meshData.normalBuffer);
  //      gl.vertexAttribPointer(billBoardShaders.vertexNormalAttribute,  board.meshData.normalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  board.meshData.indexBuffer);
        
		gl.uniformMatrix4fv(billBoardShaders.mvMatrixUniform, false, board.positionMatrix);
        var normalMatrix = mat3.create();
        mat3.fromMat4(normalMatrix, board.positionMatrix);
        mat3.invert(normalMatrix, normalMatrix);
        mat3.transpose(normalMatrix, normalMatrix);
    //    gl.uniformMatrix3fv(billBoardShaders.nMatrixUniform, false, normalMatrix);
		
		gl.uniformMatrix4fv(billBoardShaders.RMatrixUniform, false, rotMat);
        gl.drawElements(gl.TRIANGLES,  board.meshData.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		
		
		
	}

	function drawSky(model){
		gl.useProgram(skyBoxShaders);

        var camMat = keyboardControls.getCamMatrix();
        var time = keyboardControls.getElapsedTime();
		var temp = mat4.clone(camMat);
		temp[12]=0;
		temp[13]=-0.5;
		temp[14]=0;
        gl.uniformMatrix4fv(skyBoxShaders.camMatrix, false, temp);
        gl.uniformMatrix4fv(skyBoxShaders.frustum, false, frustum);

        if (model.rotVec != null) {
            mat4.rotate(model.positionMatrix, model.positionMatrix, degToRad(model.rotSpeed * time), [model.rotVec.x, model.rotVec.y, model.rotVec.z]);
            gl.uniformMatrix4fv(skyBoxShaders.mvMatrixUniform, false, model.positionMatrix);
        } else{
            mat4.identity(temp);
            gl.uniformMatrix4fv(skyBoxShaders.mvMatrixUniform, false, temp);
        }

		gl.activeTexture(gl.TEXTURE0);
        if (model.texture.isFinished) {
                gl.bindTexture(gl.TEXTURE_2D, model.texture);
            } else{
                gl.bindTexture(gl.TEXTURE_2D, oneByOneTexture);
            }
		gl.uniform1i(skyBoxShaders.samplerUniform, 0);
		
		gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.vertexBuffer);
        gl.vertexAttribPointer(skyBoxShaders.vertexPositionAttribute,  model.meshData.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        if(! model.meshData.textures.length){
            gl.disableVertexAttribArray(skyBoxShaders.textureCoordAttribute);
       } else {
            gl.enableVertexAttribArray(skyBoxShaders.textureCoordAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.textureBuffer);
            gl.vertexAttribPointer(skyBoxShaders.textureCoordAttribute,  model.meshData.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  model.meshData.indexBuffer);

        gl.drawElements(gl.TRIANGLES,  model.meshData.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	}
	
    function drawModel(model) {
        gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.vertexBuffer);
        gl.vertexAttribPointer(teapotShader.vertexPositionAttribute,  model.meshData.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.activeTexture(gl.TEXTURE0);
        if (model.texture.isFinished) {
                gl.bindTexture(gl.TEXTURE_2D, model.texture);
            } else{
                gl.bindTexture(gl.TEXTURE_2D, oneByOneTexture);
            }
        gl.uniform1i(teapotShader.samplerUniform, 0);

        if(! model.meshData.textures.length){
            gl.disableVertexAttribArray(teapotShader.textureCoordAttribute);
        } else {
            gl.enableVertexAttribArray(teapotShader.textureCoordAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER, model.meshData.textureBuffer);
            gl.vertexAttribPointer(teapotShader.textureCoordAttribute,  model.meshData.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }

        gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.normalBuffer);
        gl.vertexAttribPointer(teapotShader.vertexNormalAttribute,  model.meshData.normalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  model.meshData.indexBuffer);
        setMatrixUniforms(teapotShader, model);
        gl.drawElements(gl.TRIANGLES,  model.meshData.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }

    function drawTerrain(){
        gl.useProgram(terrainShader);
        var camMat = keyboardControls.getCamMatrix();
        gl.uniformMatrix4fv(terrainShader.camMatrix, false, camMat);
        // gl.uniformMatrix4fv(terrainShader.camMatrix, false, camMatrix);
        gl.uniformMatrix4fv(terrainShader.frustum, false, frustum);
        // now to render the mesh

        gl.activeTexture(gl.TEXTURE0);
        if (noiseBumpMap.isFinished) {
                gl.bindTexture(gl.TEXTURE_2D, noiseBumpMap);
            } else{
                gl.bindTexture(gl.TEXTURE_2D, oneByOneTexture);
        }
        gl.uniform1i(terrainShader.samplerUniform, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER,  terrain.vertexBuffer);
        gl.vertexAttribPointer(terrainShader.vertexPositionAttribute,  terrain.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER,  terrain.colorBuffer);
        gl.vertexAttribPointer(terrainShader.vertexColorAttribute,  terrain.colorBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER,  terrain.normalBuffer);
        gl.vertexAttribPointer(terrainShader.vertexNormalAttribute,  terrain.normalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  terrain.indexBuffer);

        // gl.uniformMatrix4fv(terrainShader.mvMatrixUniform, false, terrain.positionMatrix);
        setMatrixUniforms(terrainShader, terrain);

        gl.drawElements(gl.TRIANGLES,  terrain.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }
	
    var once = false;

    function tick() {
        requestAnimFrame(tick);
        keyboardControls.handleKeys(ourObjects);
        drawScene();
        keyboardControls.animate();
    }

    function loadObjects(){
        OBJ.downloadMeshes({
			'skyBox': 'objects/skybox.obj',
            'cubePlusMedium': 'objects/cubePlusMedium.obj',
            'rectanglePlusMedium': 'objects/rectanglePlusMedium.obj',
            'teapot': 'objects/teapot.obj',
            'eHouse': 'objects/emilHouse3.obj',
			'billBoard': 'objects/openbox.obj',
			'outerTerrain': 'objects/outerTerrain.obj'
        }, webGLAddObj);
    }

    function webGLStart() {
        var canvas = document.getElementById("lesson14-canvas");
        initGL(canvas);
        initTextures();
        initShaders();
        mat4.perspective(frustum, 45, gl.viewportWidth / gl.viewportHeight, 0.1, 200.0);
        loadObjects();
        keyboardControls = new keyboardControls();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;

        tick();
    }

</script>

</head>

<body onload="webGLStart();">
    <canvas id="lesson14-canvas" style="border: none;" width="1000" height="500"></canvas>

    <br/>

    <input type="checkbox" id="specular" checked /> Show specular highlight<br/>
    <input type="checkbox" id="lighting" checked /> Use lighting<br/>

    Texture:
    <select id="texture">
        <option value="none">None</option>
        <option selected value="galvanized">Galvanized</option>
        <option value="earth">Earth</option>
    </select>
    <br/>

    <h2>Material:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Shininess:</b>
            <td><input type="text" id="shininess" value="32.0" />
        </tr>
    </table>

    <h2>Point light:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Location:</b>
            <td>X: <input type="text" id="lightPositionX" value="-10.0" />
            <td>Y: <input type="text" id="lightPositionY" value="4.0" />
            <td>Z: <input type="text" id="lightPositionZ" value="-20.0" />
        </tr>
        <tr>
            <td><b>Specular colour:</b>
            <td>R: <input type="text" id="specularR" value="0.8" />
            <td>G: <input type="text" id="specularG" value="0.8" />
            <td>B: <input type="text" id="specularB" value="0.8" />
        </tr>
        <tr>
            <td><b>Diffuse colour:</b>
            <td>R: <input type="text" id="diffuseR" value="0.8" />
            <td>G: <input type="text" id="diffuseG" value="0.8" />
            <td>B: <input type="text" id="diffuseB" value="0.8" />
        </tr>
    </table>

    <h2>Ambient light:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Colour:</b>
            <td>R: <input type="text" id="ambientR" value="0.2" />
            <td>G: <input type="text" id="ambientG" value="0.2" />
            <td>B: <input type="text" id="ambientB" value="0.2" />
        </tr>
    </table>
    <br/>
</body>

</html>
