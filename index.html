<html>

<head>
<title>Learning WebGL &mdash; lesson 1</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="utils/jquery-1.11.2.min.js"></script>
<script type="text/javascript" src="utils/gl-matrix.js"></script>
<script type="text/javascript" src="utils/loadShaderUtil.js"></script>
<script type="text/javascript" src="utils/webgl-obj-loader.js"></script>
<script type="text/javascript" src="utils/webgl-utils.js"></script>

<script type="text/javascript">

    var gl;
	var MAX_DISTANCE = 10000;
    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    var shaderProgram;

    function initShaders() {

        shaderProgram = utils.addShaderProg(gl, 'teapot.vertex', 'teapot.frag');

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

        shaderProgram.frustum = gl.getUniformLocation(shaderProgram, "frustum");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
        shaderProgram.camMatrix = gl.getUniformLocation(shaderProgram, "camMatrix");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
        shaderProgram.materialShininessUniform = gl.getUniformLocation(shaderProgram, "uMaterialShininess");
        shaderProgram.showSpecularHighlightsUniform = gl.getUniformLocation(shaderProgram, "uShowSpecularHighlights");
        shaderProgram.useTexturesUniform = gl.getUniformLocation(shaderProgram, "uUseTextures");
        shaderProgram.useLightingUniform = gl.getUniformLocation(shaderProgram, "uUseLighting");
        shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientColor");
        shaderProgram.pointLightingLocationUniform = gl.getUniformLocation(shaderProgram, "uPointLightingLocation");
        shaderProgram.pointLightingSpecularColorUniform = gl.getUniformLocation(shaderProgram, "uPointLightingSpecularColor");
        shaderProgram.pointLightingDiffuseColorUniform = gl.getUniformLocation(shaderProgram, "uPointLightingDiffuseColor");
    }

    function handleLoadedTexture(texture) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);

        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    var galvanizedTexture;
    var earthTexture;

    function initTextures() {

        galvanizedTexture = gl.createTexture();
        galvanizedTexture.image = new Image();
        galvanizedTexture.image.onload = function () {
            handleLoadedTexture(galvanizedTexture)
        }
        galvanizedTexture.image.src = "textures/arroway.de_metal+structure+06_d100_flat.jpg";

        earthTexture = gl.createTexture();
        earthTexture.image = new Image();
        earthTexture.image.onload = function () {
            handleLoadedTexture(earthTexture)
        }
        earthTexture.image.src = "textures/earth.jpg";
    }

    var camMatrix = mat4.create();
    var frustum = mat4.create();

    function setMatrixUniforms(model) {
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, model.positionMatrix);

        var normalMatrix = mat3.create();
        mat3.fromMat4(normalMatrix, model.positionMatrix);
        //mat3.invert(normalMatrix, normalMatrix);
        //mat4.toInverseMat3(model.positionMatrix, normalMatrix);
        //mat3.transpose(normalMatrix, normalMatrix);
        gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    var ourMeshes = {};
    var ourObjects = [];

    function webGLAddObj(meshes){
        ourMeshes = meshes;
        OBJ.initMeshBuffers(gl, ourMeshes.teapot);
        createObjects();
    }

    function createObjects(){
        var teapot1, teapot2, mesh;
        mesh = ourMeshes.teapot;
        teapot1 = {name:"teapot1"};
        teapot1.meshData = mesh;
		teapot1.radius = 10;

        teapot2 = {name:"teapot2"};
        teapot2.meshData = mesh;
		teapot2.radius = 5;

        var teapot1Mat = mat4.create(), teapot2Mat = mat4.create();

        mat4.identity(teapot1Mat);
        mat4.translate(teapot1Mat, teapot1Mat, [-10, 0, -40]);
        mat4.rotate(teapot1Mat, teapot1Mat, degToRad(23.4), [1, 0, -1]);
        mat4.rotate(teapot1Mat, teapot1Mat, degToRad(teapotAngle), [0, 1, 0]);
        teapot1.positionMatrix = teapot1Mat;
        ourObjects.push(teapot1);

        mat4.identity(teapot2Mat);
        mat4.translate(teapot2Mat, teapot2Mat, [10, 0, -40]);
        mat4.rotate(teapot2Mat, teapot2Mat, degToRad(-23.4), [1, 0, -1]);
        mat4.rotate(teapot2Mat, teapot2Mat, degToRad(-teapotAngle), [0, 1, 0]);
        teapot2.positionMatrix = teapot2Mat;
        ourObjects.push(teapot2);
    }

    var teapotAngle = 180;

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        var specularHighlights = document.getElementById("specular").checked;
        gl.uniform1i(shaderProgram.showSpecularHighlightsUniform, specularHighlights);

        var lighting = document.getElementById("lighting").checked;
        gl.uniform1i(shaderProgram.useLightingUniform, lighting);
        if (lighting) {
            gl.uniform3f(
                shaderProgram.ambientColorUniform,
                parseFloat(document.getElementById("ambientR").value),
                parseFloat(document.getElementById("ambientG").value),
                parseFloat(document.getElementById("ambientB").value)
            );

            gl.uniform3f(
                shaderProgram.pointLightingLocationUniform,
                parseFloat(document.getElementById("lightPositionX").value),
                parseFloat(document.getElementById("lightPositionY").value),
                parseFloat(document.getElementById("lightPositionZ").value)
            );

            gl.uniform3f(
                shaderProgram.pointLightingSpecularColorUniform,
                parseFloat(document.getElementById("specularR").value),
                parseFloat(document.getElementById("specularG").value),
                parseFloat(document.getElementById("specularB").value)
            );

            gl.uniform3f(
                shaderProgram.pointLightingDiffuseColorUniform,
                parseFloat(document.getElementById("diffuseR").value),
                parseFloat(document.getElementById("diffuseG").value),
                parseFloat(document.getElementById("diffuseB").value)
            );
        }

        var texture = document.getElementById("texture").value;
        gl.uniform1i(shaderProgram.useTexturesUniform, texture != "none");

        gl.uniformMatrix4fv(shaderProgram.camMatrix, false, camMatrix);

        gl.activeTexture(gl.TEXTURE0);
        if (texture == "earth") {
            gl.bindTexture(gl.TEXTURE_2D, earthTexture);
        } else if (texture == "galvanized") {
            gl.bindTexture(gl.TEXTURE_2D, galvanizedTexture);
        }
        gl.uniform1i(shaderProgram.samplerUniform, 0);

        gl.uniform1f(shaderProgram.materialShininessUniform, parseFloat(document.getElementById("shininess").value));

        for (var i = 0; i < ourObjects.length; i++) {
            drawModel(ourObjects[i]);
        };
    }

	function getDistanceToModel(pos){
		
		return Math.sqrt(pos.x*pos.x+pos.y*pos.y+pos.z*pos.z) //just between points

	}
	function isColliding(someModels, cameraPosition){
		var shortestDist = MAX_DISTANCE, distance = 0;
		var modelPositionVec = {name:"modelPosVec"};
		var indexOfClosest = 0;
		var difference = 0;
		for (var i = 0; i < someModels.length; i++){
			 modelPositionVec.posVec = getModelPosistion(someModels[i].positionMatrix);
			distance = getDistanceToModel(modelPositionVec.posVec); 
		   if( distance < shortestDist){
				shortestDist = distance;
				indexOfClosest = i;
			}
		};
		difference = someModels[indexOfClosest].radius-shortestDist;
		if(difference > 0 ){
			return difference;
		}
		else if(difference > -0.1){ //returns negative value for when camera is pretty close to object
			return -difference;
		}
		return 0; 
	}
	function getModelPosistion(posMatrix){
		var pos = mat4.create();
		mat4.multiply(pos, camMatrix, posMatrix);
		var posVec = {name:"posVec"};
		posVec.x = pos[12];
		posVec.y = pos[13];
		posVec.z = pos[14];
		return posVec;
	}
	
    function drawModel(model) {
        // now to render the mesh
        gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.vertexBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,  model.meshData.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        if(! model.meshData.textures.length){
            gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
        } else {
            gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.textureBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute,  model.meshData.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }

        gl.bindBuffer(gl.ARRAY_BUFFER,  model.meshData.normalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute,  model.meshData.normalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  model.meshData.indexBuffer);
        setMatrixUniforms(model);
        gl.drawElements(gl.TRIANGLES,  model.meshData.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }


    var lastTime = 0;
    var camMove = mat4.create();
	var lastStepX = 0, lastStepY = 0, lastStepZ = 0;
	var elapsed;

    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            elapsed = timeNow - lastTime;
            yaw += yawRate * elapsed;
            pitch += pitchRate * elapsed;

            teapotAngle += 0.05 * elapsed;
            mat4.identity(camMove);

            mat4.identity(camMove);

            if (pitch != 0){
                mat4.rotate(camMove, camMove, degToRad(-pitch), [1, 0, 0]);
                mat4.multiply(camMatrix, camMove, camMatrix);
                pitch = 0;
            }
            mat4.identity(camMove);

            if (yaw != 0) {
                mat4.rotate(camMove, camMove, degToRad(-yaw), [0, 1, 0]);
                mat4.multiply(camMatrix, camMove, camMatrix);
                yaw = 0;
            }
            if (speedX != 0 || speedY != 0 || speedZ != 0) {
				lastStepX = speedX * elapsed;
				lastStepY = speedY * elapsed;
				lastStepZ = speedZ * elapsed;
                mat4.translate(camMove, camMove, [speedX * elapsed, speedY * elapsed, speedZ * elapsed]);
                mat4.multiply(camMatrix, camMove, camMatrix);

            //    joggingAngle += elapsed * 0.2; // 0.6 "fiddle factor" - makes it feel more realistic :-)
            //    yPos += Math.sin(degToRad(joggingAngle)) / 40 + 0.2
            }
        }
        lastTime = timeNow;
    }


    function tick() {
        requestAnimFrame(tick);
        handleKeys();
        drawScene();
        animate();
    }

    function loadObjects(){
        OBJ.downloadMeshes({
            'teapot': 'objects/teapot.obj'            
        }, webGLAddObj);
    }

    function webGLStart() {
        var canvas = document.getElementById("lesson14-canvas");
        initGL(canvas);
        loadObjects();
        initShaders();
        initTextures();
        mat4.identity(camMatrix);

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;

        mat4.perspective(frustum, 45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
        gl.uniformMatrix4fv(shaderProgram.frustum, false, frustum);

        tick();
    }

        var lastTime = 0;
    // Used to make us "jog" up and down as we move forward.
    var joggingAngle = 0;

    var currentlyPressedKeys = {};

    function handleKeyDown(event) {
        currentlyPressedKeys[event.keyCode] = true;
    }


    function handleKeyUp(event) {
        currentlyPressedKeys[event.keyCode] = false;
    }


    var pitch = 0;
    var pitchRate = 0;

    var yaw = 0;
    var yawRate = 0;

    var xPos = 0;
    var yPos = 0.4;
    var zPos = 0;

    var speedZ = 0, speedY = 0, speedX = 0;
    function handleKeys() {
        // Look up or down
        if (currentlyPressedKeys[104]) {
            // Numpad 8
            pitchRate = 0.1;
        } else if (currentlyPressedKeys[101]) {
            // Numpad 5
            pitchRate = -0.1;
        } else {
            pitchRate = 0;
        }

        // look righ or left
        if (currentlyPressedKeys[100]) {
            // Numpad 4
            yawRate = 0.1;
        } else if (currentlyPressedKeys[102]) {
            // Numpad 6
            yawRate = -0.1;
        } else {
            yawRate = 0;
        }

		var changeX = false, changeY = false, changeZ = false, hasCollided = false;
		
		if(currentlyPressedKeys[87] || currentlyPressedKeys[83] || currentlyPressedKeys[68] || currentlyPressedKeys[65] || currentlyPressedKeys[81] || currentlyPressedKeys[69] ){
		
	   // Go forward or backward
        if (currentlyPressedKeys[87] ) {
            //  W
			speedZ = 0.003;
			changeZ = true;
			
        } else if (currentlyPressedKeys[83]) {
            // S
			console.log("S");
            speedZ = -0.003;
			changeZ = true;
        } else {
            speedZ = 0;
			changeZ= false;
        }

        // Go righ or left
        if (currentlyPressedKeys[68]) {
            //  D
            speedX = -0.003;
			changeX = true;
        } else if (currentlyPressedKeys[65]) {
            //  A
            speedX = 0.003;
			changeX = true;
        } else {
            speedX = 0;
			changeX = false;
        }

        // Go up or down
        if (currentlyPressedKeys[69]) {
            //  E
            speedY = 0.003;
			changeY = true;
        } else if (currentlyPressedKeys[81]) {
            //  Q
            speedY = -0.003;
			changeY = true;
        } else {
            speedY = 0;
			changeY = false;
        }
		var collisionValue = isColliding(ourObjects);
		if( collisionValue > 0.05){
		
			if (changeZ ) {
				speedZ = -collisionValue*100*speedZ;
			}
			if (changeY ) {
				speedY = -collisionValue*100*speedY;
			}
			if (changeX ) {
				speedX = -collisionValue*100*speedX;
			}
		}

		}	//no keys pressed
		else {
		speedX = 0;
		speedY = 0;
		speedZ = 0;
		}
		prevColl = collisionValue;
    }

</script>

</head>

<body onload="webGLStart();">
    <canvas id="lesson14-canvas" style="border: none;" width="500" height="500"></canvas>

    <br/>

    <input type="checkbox" id="specular" checked /> Show specular highlight<br/>
    <input type="checkbox" id="lighting" checked /> Use lighting<br/>

    Texture:
    <select id="texture">
        <option value="none">None</option>
        <option selected value="galvanized">Galvanized</option>
        <option value="earth">Earth</option>
    </select>
    <br/>

    <h2>Material:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Shininess:</b>
            <td><input type="text" id="shininess" value="32.0" />
        </tr>
    </table>

    <h2>Point light:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Location:</b>
            <td>X: <input type="text" id="lightPositionX" value="-10.0" />
            <td>Y: <input type="text" id="lightPositionY" value="4.0" />
            <td>Z: <input type="text" id="lightPositionZ" value="-20.0" />
        </tr>
        <tr>
            <td><b>Specular colour:</b>
            <td>R: <input type="text" id="specularR" value="0.8" />
            <td>G: <input type="text" id="specularG" value="0.8" />
            <td>B: <input type="text" id="specularB" value="0.8" />
        </tr>
        <tr>
            <td><b>Diffuse colour:</b>
            <td>R: <input type="text" id="diffuseR" value="0.8" />
            <td>G: <input type="text" id="diffuseG" value="0.8" />
            <td>B: <input type="text" id="diffuseB" value="0.8" />
        </tr>
    </table>

    <h2>Ambient light:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Colour:</b>
            <td>R: <input type="text" id="ambientR" value="0.2" />
            <td>G: <input type="text" id="ambientG" value="0.2" />
            <td>B: <input type="text" id="ambientB" value="0.2" />
        </tr>
    </table>
    <br/>
</body>

</html>
